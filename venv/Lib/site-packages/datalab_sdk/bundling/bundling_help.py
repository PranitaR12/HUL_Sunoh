import logging
import shutil
import os
from tempfile import ( # type: ignore[attr-defined]
    gettempdir,
    _get_candidate_names,
)
from typing import List, Callable


def bundle_app(
    bundle_file_path: str = "./tool", 
    required_paths: List[str] = ["./tool"],
    optional_paths: List[str] = [],
    custom_functions: List[Callable] = [],
    app_py_name: str = None,
):
    """
    Helper function to arrange the files in the given folder into the correct format for uploading to Datalab.
    Note the the bundle must have app.py at its root (see the app_py_name argument).

    Arguments:
        bundle_file_path: str -- Relative path to the file the app will be bundled into, without the extension.
        required_paths: List[str] -- Relative paths to files or directories to include in the bundle. An exception is thrown if they are not found.
            It will be placed at the root of the app directory in the bundle (e.g. "./a/b/c" will become "./app/c").
        optional_paths: List[str] -- Relative paths to files or directories to include in the bundle if they exist.
            It will be placed at the root of the app directory in the bundle (e.g. "./a/b/c" will become "./app/c").
        custom_functions: List[Callable] -- Additional functions to run before finalising the bundle to help create 
            the appropriate content and structure. The path to the root of the app folder in the bundle (str) is given as an argument.
        app_py_name: str -- Name of entry point module if it is not app.py, excluding extension.

    Returns:
        str -- Relative path to the bundle file, including extension.
    """
    # Use an temporary folder to prepare files together for archiving
    temporary_bundle_path = create_temporary_file_path()
    logging.debug(f"Bundling app using temporary directory {temporary_bundle_path}")
    os.mkdir(temporary_bundle_path)

    # Datalab apps should be contained within an "app" folder within the bundle
    app_directory_path = os.path.join(temporary_bundle_path, "app")
    os.mkdir(app_directory_path)

    try:
        # Add all required files and folders
        for path in required_paths:
            copy_file_or_directory(path, app_directory_path)

        # Add all optional files and folders
        for path in optional_paths:
            if os.path.exists(path):
                copy_file_or_directory(path, app_directory_path)

        # Rename the entry point module if required
        if app_py_name:
            shutil.move(
                os.path.join(app_directory_path, f"{app_py_name}.py"), 
                os.path.join(app_directory_path, "app.py")
            )

        # Run any additional operations
        for function in custom_functions:
            function(app_directory_path)

        # Check we have a main.py and a Pipfile
        if not os.path.exists(os.path.join(app_directory_path, "app.py")):
            raise FileNotFoundError(
                "No app.py file in bundle. Add one or use the app_py_name argument to pass in one with an alternate name."
            )
        if not os.path.exists(os.path.join(app_directory_path, "Pipfile")):
            raise FileNotFoundError(
                "No Pipfile file in bundle. Add one configured for building the app."
            )

        # Build the zip file
        bundle_file_path = shutil.make_archive(bundle_file_path, "gztar", temporary_bundle_path, "app")

    finally:
        # Remove the temp folder
        shutil.rmtree(temporary_bundle_path, ignore_errors=True)

    return bundle_file_path


def copy_file_or_directory(source: str, destination: str):
    """
    Helper function to copy the file or directory at the source path to the destination path.
    
    Arguments:
        source: str -- File or directory to copy. 
            For directories, certain files are ignored (see IGNORE_PATTERNS).
        destination: str -- Path to copy the file or directory to.
            If a directory, it will be placed at the root of the bundle (e.g. "./a/b/c" will become "./c").
            This is to facilitate combining directories which are common to multiple apps.
    """
    if os.path.isfile(source):
        shutil.copy(source, destination)
    else:
        shutil.copytree(
            source, 
            os.path.join(destination, os.path.basename(source)), 
            ignore=IGNORE_PATTERNS, 
            dirs_exist_ok=True,
        )


def create_temporary_file_path():
    """
    Creates a new path to use for a temporary file.
    """
    return os.path.join(gettempdir(), next(_get_candidate_names()))


IGNORE_PATTERNS = shutil.ignore_patterns(
    # Unnecessary parts of the codebase for deployment
    "Makefile",
    "bundle.py",
    "README.md",
    "test_*.py",
    "*_test.py",

    # Tooling support and their generated files
    ".gitignore",
    ".dockerignore"
    ".mypy_cache",
    "__pycache__",
    ".coverage",
    ".vscode",

    # Other unlikely files which may have been created
    "app.tar.gz",
    "tmp",
    "temp.auth",
)
