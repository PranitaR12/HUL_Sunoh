from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping, Optional, cast

import requests
from marshmallow import ValidationError
from marshmallow_dataclass import class_schema

# want to make easy import for clients of SDK
from datalab_sdk.api.exceptions import *
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)

# import the likely types so clients don't need to know where to find them
from datalab_sdk.api.minerva.rpeui.types.basic_metadata import (
    TokenInformation,
    VersionInformation,
    PlmReferenceRecipe,
    FormulaRecipe, 
    RpeInformation, 
    RpeIngredient, 
    RpeTfc,
    CalculateRequest,
    CalculateMetadata,
    CalculateResponse,
)
from datalab_sdk.api.common.schema import LowerCamelCaseSchema
from datalab_sdk.logger import logger

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")


class MinervaRpeBasicClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

    def get_token_info(
      self, token
    ) -> TokenInformation:
        """Get information about the supplied authentication token.
        The primary use case of this API is to validate an authentication token to make
        sure it can be used to access the API. 

        Arguments:
            token: str -- The auth token to use for the API call.

        Returns:
            TokenInformation - Name and email address associated with the supplied authentication token.

        Errors:
            AuthNotValid - If token is invalid.
        """
        return self.__request_get(
            path="tokeninfo",
            token=token,
            argument="",
            output_class=TokenInformation
        )

    def get_version_info(
      self, token
    ) -> VersionInformation:
        """Get information about model and database versions.

        Arguments:
            token: str -- The auth token to use for the API call.

        Returns:
            VersionInformation - Version information from the database and models currently in use. 
            The model version and database version are expressed as strings in 
            ISO8601 date/time format with a time zone identifier.

        Errors:
            AuthNotValid - If token is invalid.
        """
        return self.__request_get(
            path="versioninfo",
            token=token,
            argument="",
            output_class=VersionInformation
        )

    def calculate(
      self, 
      token, 
      request: CalculateRequest,
    ) -> CalculateResponse:
        """Runs calculations on a single recipe.

        Arguments:
            token: str -- The auth token to use for the API call.
            request: RpeRequest -- Defines the recipe and the scope of calculation.
            The recipe provided can take various forms:
            - A single PLM reference without alternate/version (with optional additional
            properties)
            - A single PLM reference with alternate/version (with optional additional
            properties)
            - An explicit formula (with an optional PLM reference and additional properties)

            If a PLM reference without alternate and version, and no formula is provided,
            then the current version of the highest alternate is taken from the Agile R&D data
            set, and that formula is then used to run the calculations on. If a specific alternate
            and version is specified, then that specific alternate is used instead.

        Returns:
            CalculateResponse - Includes the calculated properties for the given calculation scope.

        Errors:
            AuthNotValid - If token is invalid.
        """
        return self.__request_post(
            path="calculate",
            token=token,
            data=request,
            input_class=CalculateRequest,
            output_class=CalculateResponse
        )

################################################################################
# HELPERS
################################################################################

    def __request_get(
        self, path: str, token: str, argument: str,
        output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        output_schema = class_schema(output_class, base_schema=LowerCamelCaseSchema)

        # make call
        url = EnvironmentConfig.get_minerva_rep_api_url(self._environment, path, argument)
        
        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            logger.debug(err)
            if not_found is not None:
                # Convert RPE specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    def __request_post(
        self, 
        path: str, 
        token: str, 
        data: INPUT_CLASS,
        input_class: Type[INPUT_CLASS], 
        output_class: Optional[Type[OUTPUT_CLASS]],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None,
    ) -> OUTPUT_CLASS:
        input_schema = class_schema(input_class, base_schema=LowerCamelCaseSchema)

        # prepare input body - may be invalid
        try:
            body = input_schema().dump(data)
            info(body)
        except Exception as err:
            logger.debug(err)
            debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        # make call
        url = EnvironmentConfig.get_minerva_rep_api_url(self._environment, path, "")

        # Special case where we don't expect a response
        if output_class is None:
            try:
                response = self.post(url, token, body, parse_response=False)
            except ResourceNotFound as err:
                logger.debug(err)
                if not_found is not None:
                    # Convert RPE specific errors
                    raise not_found(err.correlation_id)
                else:
                    raise err
            return cast(OUTPUT_CLASS, None)

        # Otherwise, handle output schema
        output_schema = class_schema(output_class, base_schema=LowerCamelCaseSchema)
        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.post(url, token, body))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert RPE specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)
