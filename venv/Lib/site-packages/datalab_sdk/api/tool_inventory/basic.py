from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping, cast

import requests
from marshmallow import ValidationError
from marshmallow_dataclass import class_schema

# want to make easy import for clients of SDK
from datalab_sdk.api.exceptions import *
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)
# import the likely types so clients don't need to know where to find them
from datalab_sdk.api.tool_inventory.exceptions import *
from datalab_sdk.api.tool_inventory.types.responses.tool_info import ToolInfo
from datalab_sdk.api.tool_inventory.types.responses.tool_version_info import ToolVersionInfo
# want to make easy import for clients of SDK
from datalab_sdk.api.tool_inventory.types.responses.tool_version import ToolVersion
from datalab_sdk.api.common.schema import CamelCaseSchema
# want to make easy import for clients of SDK
from datalab_sdk.api.tool_inventory.types.shared.enums import *
# want to read query paramaters
from flask import request
from datalab_sdk.logger import logger

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")


class BasicToolInventoryClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

    def get_tool_by_id(
        self, token: str, tool_id: str
    ) -> ToolInfo:
        """Get tool information from Tool ID including all versions.

        Arguments:
            token: str -- The auth token to use for the API call
            tool_id: str -- the ID of the tool

        Returns:
            ToolInfo -- information about the tool including the different versions

        Errors:
            AuthNotValid - if token is invalid
            ToolNotFound - if the tool ID is not found in the database
        """

        return self.__request_get(
            path="tool",
            token=token,
            argument=tool_id,
            output_class=ToolInfo,
            not_found=lambda x: ToolNotFound(tool_id, x)
        )

    def get_tool_version_by_id(
        self, token: str, tool_id: str, version_id: str
    ) -> ToolVersionInfo:
        """Get tool version from Tool ID and version ID.

        Arguments:
            token: str -- The auth token to use for the API call
            tool_id: str -- the ID of the tool
            version_id: str -- the requested version

        Returns:
            ToolVersionInfo -- information about the tool version

        Errors:
            AuthNotValid - if token is invalid
            ToolVersionNotFound - if the tool version for the requested tool ID is not found in the database
        """

        return self.__request_get(
            path="tool",
            token=token,
            argument=f"{tool_id}/version/{version_id}",
            output_class=ToolVersionInfo,
            not_found=lambda x: ToolVersionNotFound(tool_id, version_id, x)
        )

    def get_tool_latest_approved_version(
        self, token: str, tool_id: str
    ) -> ToolVersionInfo:
        """Get latest approved tool version for tool ID.

        Arguments:
            token: str -- The auth token to use for the API call
            tool_id: str -- the ID of the tool

        Returns:
            ToolVersionInfo -- information about the tool version

        Errors:
            AuthNotValid - if token is invalid
            ApprovedToolVersionNotFound - if no approved tool version for the requested tool ID is found in the database
        """

        return self.__request_get(
            path="tool",
            token=token,
            argument=f"{tool_id}/latestapproved",
            output_class=ToolVersionInfo,
            not_found=lambda x: ApprovedToolVersionNotFound(tool_id, x)
        )

    def get_tool_approved_versions(
        self, token: str, tool_id: str
    ) -> ToolInfo:
        """Get all approved tool versions for tool ID.

        Arguments:
            token: str -- The auth token to use for the API call
            tool_id: str -- the ID of the tool

        Returns:
            ToolInfo -- information about the approved tool versions

        Errors:
            AuthNotValid - if token is invalid
            ApprovedToolVersionNotFound - if no approved tool version for the requested tool ID is found in the database
        """

        return self.__request_get(
            path="tool",
            token=token,
            argument=f"{tool_id}/approved",
            output_class=ToolInfo,
            not_found=lambda x: ApprovedToolVersionNotFound(tool_id, x)
        )


    def get_tool_version_id(self):
        """
        Get the Tool Version Id from request Query Parameters
        """
        try:            
            return request.args.get('toolVersionId')
        except Exception as e:
            logger.debug(e)
            error(e)
            return ""

    def get_tool_config_by_version_id(
        self, token: str, version_id: str
    ) -> JSONResponseType:
        """Get the tool version configuration using tool version ID.

        Arguments:
            token: str -- The auth token to use for the API call
            version_id: str -- the requested tool version

        Returns:
            ToolVersion.configuration -- Configuration of the specific version

        Errors:
            AuthNotValid - if token is invalid
            ToolVersionNotFound - if the tool version for the requested tool ID is not found in the database
        """        

        return self.__request_get_json(
            path="tool",
            token=token,
            argument=f"/version/{version_id}/config",
            not_found=lambda x: ToolVersionNotFound("",version_id, x)
        )

    def get_tool_config(
        self, token: str
    ) -> JSONResponseType:
        """Get the version configuration of current tool.

        Arguments:
            token: str -- The auth token to use for the API call

        Returns:
            ToolVersion.configuration -- Configuration of the specific version

        Errors:
            AuthNotValid - if token is invalid
            ToolVersionNotFound - if the tool version for the requested tool ID is not found in the database
        """
        version_id = self.get_tool_version_id()

        return self.__request_get_json(
            path="tool",
            token=token,
            argument=f"/version/{version_id}/config",
            not_found=lambda x: ToolVersionNotFound("",version_id, x)
        )

    def __request_get(
        self, path: str, token: str, argument: str,
        output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)

        # make call
        url = EnvironmentConfig.get_tool_inventory_api_url(self._environment, path, argument)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            logger.debug(err)
            if not_found is not None:
                # Convert tool-inventory specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)


    def __request_get_json(
        self, path: str, token: str, argument: str,
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ):
        # make call
        url = EnvironmentConfig.get_tool_inventory_api_url(
            self._environment, path, argument)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            logger.debug(err)
            if not_found is not None:
                # Convert tool-inventory specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # log and return the response
        info(response)
        return response
