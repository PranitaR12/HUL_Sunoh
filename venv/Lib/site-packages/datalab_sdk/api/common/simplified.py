from datalab_sdk.api.mme.simplified_types import (
    RawDatum,
    RunProgress
)
from datalab_sdk.api.mme.response_mappers import (
    ResponseMapper
)
from datalab_sdk.api.mme.basic import (
    Datum, 
    ModelRequirements,
    InputDefinition,
    Response,
    DatumKey,
    DataType,
    ArrayResponseContent,
    InputGroupDefinition,
    ComponentIngredient,
    ContainerDefinition
)
from datalab_sdk.api.mme.types.requests.context_path import ContextPath
from typing import cast, Union, List, Set, Iterable, Any
from logging import debug

# Base class for simplified interface to the API
class CommonSimplifiedClient():
    def __init__(self):
        pass

    def get_user_input_source(self, app: str, widget_id: str = None) -> str:
      """Get a standardised input source for user inputs"""
      if widget_id is not None:
          return f"user:{app}:{widget_id}"
      else:
          return f"user:{app}"

    def get_security_groups_associated_with_inputs(self, data: List[Datum], base_set: List[str] = None) -> List[str]:
      """Gets the distinct list of groups referred to by the inputs

         Optionally a base set may be passed to add to
      """
      if base_set is None:
          base_set = []

      if data is None or len(data) == 0:
          if len(base_set) == 0:
              return []
          else:
              return list(set(base_set))
      groups = set(map(lambda x: x.response.security.security_group if x is not None and x.response is not None and x.response.security is not None else "", data))
      groups.discard(None)
      groups.discard("")
      return list(cast(Iterable[str], groups.union(set(base_set))))

    def get_data_from_raw_inputs(self, raw_inputs: List[Union[RawDatum, Datum]]) -> List[Datum]:
        """Converts a mixed list of Datum or RawDatum inputs into a list of Datum"""
        if raw_inputs is None:
            return []
        return list(
            map(
                lambda x: Datum.from_raw(
                    x.datum_key, x.value, x.unit, x.source, x.timestamp, x.security
                )
                if isinstance(x, RawDatum)
                else x,
                raw_inputs,
            )
        )

    def get_context_from_recipe(self, recipe: Union[RawDatum, Datum], context_key: str) -> Union[ContextPath, None]:
        """Gets a context path with values for the components of a recipe datum (i.e ARRAY of COMPONENT_INGREDIENTS)"""
        if recipe is None:
            return None

        ingredients: List[ComponentIngredient] = []
        if (
            isinstance(recipe, Datum)
            and recipe.response.array_response_content is not None
            and recipe.response.array_response_content.component_ingredients is not None
        ):
            ingredients.extend(recipe.response.array_response_content.component_ingredients)
        elif isinstance(recipe, RawDatum):
            ingredients.extend(cast(List[ComponentIngredient], recipe.value))

        if len(ingredients) > 0:
            values = list(map(lambda x:x.name, ingredients))
            return ContextPath(context_key, values)
        else:
            return None

    def get_input_set_from_requirements(self, requirements: ModelRequirements) -> List[InputDefinition]:
        """Gets a flat list of InputDefinitions from a ModelRequirements instance"""
        input_set = []
        if requirements is not None:
          for group in requirements.input_group_definitions:
              for input in group.input_definitions:
                  input_set.append(input)
        return input_set

    def map_from_resolved_value(self,
        resolved: Response,
        datum_key: DatumKey,
        input_def: InputDefinition,
        mapper: ResponseMapper
    ) -> Datum:

        # clone the response, injecting mapper calls to allow extended handling
        response = Response(
            container_type = mapper.container_type(input_def, resolved),
            data_type = mapper.data_type(input_def, resolved),
            source = mapper.source(input_def, resolved),
            timestamp = mapper.timestamp(input_def, resolved),
            unit = mapper.unit(input_def, resolved),
            singular_response_content = mapper.singular_response_content(input_def, resolved),
            array_response_content = mapper.array_response_content(input_def, resolved),
            encrypted_response_content = mapper.encrypted_response_content(input_def, resolved),
            security = mapper.security(input_def, resolved),
        )
        return Datum(datum_key, response)

    def filter_to_missing(self,
        needed_inputs: List[InputDefinition], prepared_inputs: Set[Datum]
    ) -> List[InputDefinition]:
        return list(filter(lambda ni: self.__datum_key_not_found(prepared_inputs, ni.datum_key), needed_inputs))

    def __datum_key_not_found(self, input_list: Set[Datum], search_key: DatumKey) -> bool:
        for i in input_list:
            if i.datum_key == search_key:
                return False
        return True

    def get_empty_array_content(self, data_type: DataType) -> ArrayResponseContent:
        empty_list: List[Any] = []
        if data_type == DataType.STRING:
            return ArrayResponseContent(strings = empty_list)
        elif data_type == DataType.NUMBER:
            return ArrayResponseContent(numbers = empty_list)
        elif data_type == DataType.DATE:
            return ArrayResponseContent(dates = empty_list)
        elif data_type == DataType.BOOLEAN:
            return ArrayResponseContent(booleans = empty_list)
        elif data_type == DataType.LIST_VALUE:
            return ArrayResponseContent(list_values = empty_list)
        elif data_type == DataType.TIME_POINT:
            return ArrayResponseContent(time_points = empty_list)
        elif data_type == DataType.NAMED_VALUE:
            return ArrayResponseContent(named_values = empty_list)
        else:
            return ArrayResponseContent(component_ingredients = empty_list)

