from datalab_sdk.api.chaining.basic import (
    RunChainOutput
)
from datalab_sdk.api.mme.basic import (
    ApplicableContext,
    RunStatus,
    Security,
    InputsValidationResult,
    InputDefinition,
    Response,
    DataType,
    ContainerType,
    Unit,
    SingularResponseContent,
    ArrayResponseContent
)
from datalab_sdk.api.mme.types.responses.result import Result
from datalab_sdk.api.mme.types.shared.datum import RawValue, DatumKey, Datum
from typing import Union, List
from dataclasses import dataclass
from datalab_sdk.api.mme.types.shared.unit import Unit

@dataclass
class ChainRunProgress:
    chain_id: str
    contexts_resolved: bool
    requirements_fulfilled: bool
    inputs_valid: bool
    has_run: bool
    run_chain_output: Union[RunChainOutput, None] = None
    validation_result: Union[InputsValidationResult, None] = None
    inputs: Union[List[Datum], None] = None
    missing_inputs: Union[List[DatumKey], None] = None
    context: Union[ApplicableContext, None] = None

    __status_map = {
        RunStatus.SUCCESS: "Chain completed successfully using inputs - see run_chain_output for results",
        RunStatus.FAILURE: "Chain failed to run with inputs - see run_chain_output for errors",
        RunStatus.NOT_AVAILABLE: "Chain was not run as it could not be found in MME"
    }

    @property
    def successfully_completed(self) -> bool:
        """True if the model was run and returned success"""
        return self.has_run and self.run_chain_output is not None and self.run_chain_output.output is not None and self.run_chain_output.output.run_status == RunStatus.SUCCESS

    def get_summary(self) -> str:
        """Gives a summary of the run"""
        summary: str = ""
        if self.has_run and self.run_chain_output is not None and self.run_chain_output.output is not None:
            summary = self.__status_map[self.run_chain_output.output.run_status]
        elif self.inputs_valid:
            summary =  "Chain not run yet, but required inputs are provided and ready for checking"
        else:
            if not self.contexts_resolved:
                summary =  "Chain was not run as applicable contexts were fully not resolved - see context for details, and inputs for latest input set"
            elif not self.requirements_fulfilled:
                summary =  "Chain was not run with inputs as required inputs were missing - see missing_inputs for details"
            else:
                summary =  "Chain was not run as inputs were not valid - see validation_result for details"

        return summary

    def get_result_by_key(self, key: DatumKey) -> Union[Result, None]:
        """Retrieves the chain result with the passed key - or None if not found"""
        found_result: Union[Result, None] = None
        if self.successfully_completed and self.run_chain_output is not None and self.run_chain_output.output is not None and self.run_chain_output.output.results is not None:
            for result in self.run_chain_output.output.results:
                if result.datum_key == key:
                    found_result = result

        return found_result

    def get_input_by_key(self, key: DatumKey) -> Union[Datum, None]:
        """Retrieves the input with the passed key - or None if not found"""
        found_input: Union[Datum, None] = None
        if self.inputs is not None:
            for input in self.inputs:
                if input.datum_key == key:
                    found_input = input
        return found_input

    def get_raw_result_by_key(self, key: DatumKey) -> Union[RawValue, None]:
        """Returns a RawValue containing the value of the model result with the passed key - or None if not found"""
        result = self.get_result_by_key(key)
        if result is not None:
            if result.response.security is not None and result.response.security.encrypted:
                return "Value redacted for current user"
            else:
                return result.response.to_raw()
        else:
            return None

    @classmethod
    def from_run_output(cls, chain_id: str, inputs: List[Datum], run_chain_output: RunChainOutput):
        return cls(chain_id, True, True, True, True, inputs=inputs, run_chain_output=run_chain_output)

    @classmethod
    def from_validation_failure(cls, chain_id: str, inputs: List[Datum], validation_result: InputsValidationResult):
        return cls(chain_id, True, True, False, False, inputs=inputs, validation_result=validation_result)

    @classmethod
    def from_inputs_ready(cls, chain_id: str, inputs: List[Datum]):
        return cls(chain_id, True, True, True, False, inputs=inputs)

    @classmethod
    def from_unfulfilled_requirements(cls, chain_id: str, inputs: List[Datum], missing_inputs: List[DatumKey]):
        return cls(chain_id, True, False, False, False, inputs=inputs, missing_inputs=missing_inputs)

    @classmethod
    def from_resolve_failure(cls,  chain_id: str, inputs: List[Datum], applicable_context: ApplicableContext):
        return cls(chain_id, False, False, False, False, inputs=inputs, context=applicable_context)
