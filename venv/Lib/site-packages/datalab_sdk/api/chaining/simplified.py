from datalab_sdk.api.chaining.basic import (
    ChainingBasicClient,
    Environment
)
from datalab_sdk.api.mme.simplified_types import (
    RawDatum
)
from datalab_sdk.api.mme.response_mappers import (
    ResponseMapper,
    ResponseMapperSet
)
from datalab_sdk.api.chaining.simplified_types import (
    ChainRunProgress,
    InputDefinition
)
from datalab_sdk.api.common.simplified import *
from datalab_sdk.api.chaining.basic import * # want to make easy import for clients of SDK
from datalab_sdk.api.mme.types.requests.correlation import Correlation
from datalab_sdk.api.mme.types.requests.context_path import ContextPath
from datalab_sdk.api.mme.types.shared.datum import Datum
from datalab_sdk.api.mme.types.shared.security import Security
from datalab_sdk.api.mme.types.requests.correlation import Correlation
from datalab_sdk.api.mme.types.requests.business_context import BusinessContext
from typing import cast, Union, List, Set, Iterable
from logging import debug

# Simplified interface to the API, giving help around the most common use cases
class ChainingSimplifiedClient(CommonSimplifiedClient):
    def __init__(self, environment: Environment = Environment.PROD):
        CommonSimplifiedClient.__init__(self)
        self.__api = ChainingBasicClient(environment=environment)

    def get_provenance_session_id(self, token):
        """Return the Provenance Correlation Id of this session

        Arguments:
            token: str -- The auth token of the current session

        Returns:
            Union[str,None] - the current Provenance Correlation Id, or None
                if there is None present on the token and noe hasn't been
                cached yet
        """
        return self.__api.get_provenance_session_id(token)

    # wrapped and simplified raw api methods
    def try_to_assemble_chain(
        self, token: str, models_to_chain: List[FixedModelReference], min_level: ModelState = ModelState.CREATED
    ) -> AssemblyResult:
        """Attempt to build a valid chain from the specified set of models.

        Arguments:
            token: str -- The auth token to use for the API call
            models_to_chain: List[FixedModelReference] -- The array of fixed model references that should be in the chain.
                Not assumed to be ordered since ordering will come from the chaining process.
            min_level: ModelState -- minimum state that is expected for models to be part of the resulting chain.
                This ensures a known level of trust is respected.
                Defaults to "Created" level.

        Returns:
            AssemblyResult - result of the attempt to chain, including the chain definition if successful, and the error messages if not

        Errors:
            AuthNotValid - if token is invalid
        """

        return self.__api.try_to_assemble_chain(token, models_to_chain, min_level)

    def create_chain_from_definition(
        self, token: str, description: str, version: str, chain_definition: ChainDefinition
    ) -> str:
        """Create a chain from the ChainDefinition.

        Arguments:
            token: str -- The auth token to use for the API call
            description: str -- the description of the chain, should have a business meaning 
                to help users understand the purpose of the chain in other contexts
            version: str -- version given to the chain by the client who can use 
                any value that makes sense to their use case
            chain_definition: ChainDefinition -- definition of the chain to create,
                could be found in the output of tryToAssembleChain

        Returns:
            str - string id of the created chain, to be retained by the system client
                because it isn’t possible to find it again with API calls

        Errors:
            AuthNotValid - if token is invalid
        """
        create_chain_output = self.__api.create_chain(token, description, version, chain_definition)
        return create_chain_output.chain_id

    def create_chain(
        self, token: str, description: str, version: str,
        models_to_chain: List[FixedModelReference], min_level: ModelState
    ) -> str:
        """Assemble the chain including the provided list of models, and create it if assembly is successful

        Arguments:
            token: str -- The auth token to use for the API call
            description: str -- Business meaningful description that should explain the purpose of the chain
            version: str -- version to give to the chain
            models_to_chain: List[FixedModelReference] -- List of models to include in the chain
            min_level: ModelState -- Minimum state of models to look for

        Returns:
            str - Chain ID of the freshly created chain (this ID can only be retrieved at creation)

        Errors:
            ChainAssemblyFailed - if the chain assembly failed before the creation step
            AuthNotValid - if token is invalid
        """
        result = self.try_to_assemble_chain(token, models_to_chain, min_level)
        if result.succeeded:
            chain_definition = result.chain_definition
            if chain_definition is not None:
                chain_id = self.create_chain_from_definition(token, description, version, chain_definition)
                return chain_id
        if result.errors is not None:
            raise ChainAssemblyFailed(" / ".join(list(result.errors)))
        else:
            raise ChainAssemblyFailed("Unknown error during chain assembly")

    def delete_chain(
        self, token: str, chain_id: str
    ):
        """Remove the chain identified by chain_id and release the models that were registered by the chain

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID of a chain that was previously created

        Returns:
            nothing

        Errors:
            AuthNotValid - if token is invalid
        """
        self.__api.delete_chain_by_id(token, chain_id)

    def get_chain_requirements(self, token: str, chain_id: str
    ) -> ChainRequirements:
        """Find the requirements for running the chain identified by the ID 

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID of a chain that was previously created

        Returns:
            ChainRequirements - full definition of requirements to run the chain

        Errors:
            ChainNotFound - if the chain ID isn’t found
            AuthNotValid - if token is invalid
        """

        return self.__api.get_chain_requirements_by_id(token, chain_id)

    def get_chain_definition(self, token: str, chain_id: str
    ) -> SavedChainDefinition:
        """Find the saved definition of the chain identified by the ID 

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID of a chain that was previously created

        Returns:
            SavedChainDefiniton - full definition of the chain, including description and version

        Errors:
            ChainNotFound - if the chain ID isn’t found
            AuthNotValid - if token is invalid
        """

        return self.__api.get_chain_definition_by_id(token, chain_id)

    def get_chain_outputs(self, token: str, chain_id: str
    ) -> ChainOutputs:
        """Get the definition of the outputs the chain will return

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID of a chain that was previously created

        Returns:
            ChainOutputs - full definition of outputs the chain will returns

        Errors:
            ChainNotFound - if chain ID isn’t found
            ResourceNotFound - if chain definition is empty
            AuthNotValid - if token is invalid
        """
        saved_chain_definition = self.get_chain_definition(token, chain_id)

        if saved_chain_definition.chain_definition is None:
            message = f"Chain definition not found for existing chain ID {chain_id}"
            debug(message)
            raise ResourceNotFound(message)

        chain_outputs = ChainOutputs(
            outputs=saved_chain_definition.chain_definition.output_definitions
            )

        return chain_outputs

    def resolve_input_contexts(
        self, token: str, applicable_context: ApplicableContext,
    ) -> ApplicableContext:
        """Try to resolve applicable contexts into Responses that can be used with a chain

        Arguments:
            token: str -- The auth token to use for the API call
            applicable_context: ApplicableContext -- The current definition of contexts that apply
                and the context paths that are currently applied

        Returns:
            ApplicableContext - updated definition of contexts that apply, with any values that have been resolved

        Errors:
            InputNotValid - if applicable_context not specified correctly
            AuthNotValid - if token is invalid
        """
        return self.__api.resolve_input_contexts(token, applicable_context)

    def check_inputs(
        self, token: str, chain_id: str,
        raw_inputs: List[Union[RawDatum, Datum]],
    ) -> InputsValidationResult:
        """Check if the provided inputs are ready to be sent to the chain

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The ID of the chain
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to check. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input

        Returns:
            InputsValidationResult - details of the validation results for each provided input

        Errors:
            ChainNotFound - if chain is not found
            InputNotValid - if data not specified correctly
            AuthNotValid - if token is invalid
        """
        data = self.get_data_from_raw_inputs(raw_inputs)
        return self.__api.check_inputs_by_id(token, chain_id, data)

    def run_chain(
        self, token: str, chain_id: str, raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], security_groups: List[str] = None
    ) -> RunChainOutput:
        """Run the chain with the provided inputs. These should have been checked first

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The ID of the chain to be run
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions

        Returns:
            RunChainOutput - details of the result of the chain run, including provenance details and results
                plus list of models that couldn’t be run

        Errors:
            ModelNotFound - if model is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        if security_groups is None:
            security_groups = []

        # create correlation, with passed refs and new correlation id
        data = self.get_data_from_raw_inputs(raw_inputs)
        correlation = Correlation(business_context = business_context)

        return self.__api.run_chain_by_id(token, chain_id, data, security_groups, correlation)

    def get_model_run_ids(
        self, token: str, chain_run_id: str
    ) -> List[str]:
        """Retrieve the ids of model runs that were associated with a specific chain run.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_run_id: str -- the unique id the chain run (returned in response when a chain was run)

        Returns:
            List[str] -- array of string model run ids

        Errors:
            ChainRunNotFound - if chain run id is not found
            AuthNotValid - if token is invalid
        """

        return self.__api.get_model_run_ids_by_chain_run_id(token, chain_run_id)

    # added value methods
    def run_with_data_and_context(self,
        token: str, chain_id: str,
        raw_inputs: List[Union[RawDatum, Datum]], contexts: List[ContextPath],
        business_context: List[BusinessContext], security_groups: List[str] = None,
        mappers: List[ResponseMapper] = None
    ) -> ChainRunProgress:
        """Runs the chain with the set of data, and contexts provided.
           The contexts are used to resolve inputs that have not been provided, and if this is successful
           the chain is run, after checking the inputs are valid

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID
                an ID of a chain that was previously created
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            contexts: List[ContextPath] -- The list of context paths to use to try to resolve data for the model
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - after resolving inputs
                any security groups associated with resolved inputs will be added to the list provided
                May be omitted, which will default to no specific restrictions
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned

        Returns:
            ChainRunProgress - a helper class that gives information about what happened and aids result retrieval

        Errors:
            ChainNotFound - if chain ID is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        if security_groups is None:
            security_groups = []
        if mappers is None:
            mappers = []

        # resolve chain requirements
        results = self.resolve_contexts(token, chain_id, raw_inputs, contexts, mappers)
        if results.requirements_fulfilled and results.inputs is not None:

            data = results.inputs

            # validate inputs
            validation_result = self.__api.check_inputs_by_id(token, chain_id, data)
            if not validation_result.all_passed:
                return ChainRunProgress.from_validation_failure(chain_id, data, validation_result)
            elif validation_result.warnings is not None and len(validation_result.warnings) > 0:
                debug("Inputs had validation warnings", ",".join(validation_result.warnings))

            ## add security from inputs
            security_groups = self.get_security_groups_associated_with_inputs(data, security_groups)

            # run chain
            correlation = Correlation(business_context = business_context) # capture passed refs; use new correlation ids
            result = self.__api.run_chain_by_id(token, chain_id, data, security_groups, correlation)
            return ChainRunProgress.from_run_output(chain_id, data, result)

        return results

    def run_with_data(self,
        token: str, chain_id: str,
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], security_groups: List[str] = None,
    ) -> ChainRunProgress:
        """Runs the chain with the set of data provided, after checking they are valid

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID
                an ID of a chain that was previously created
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions

        Returns:
            ChainRunProgress - a helper class that gives information about what happened and aids result retrieval

        Errors:
            ChainNotFound - if chain ID is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        if security_groups is None:
            security_groups = []

        # assemble inputs from raw data passed
        data = self.get_data_from_raw_inputs(raw_inputs)

        # validate inputs
        validation_result = self.__api.check_inputs_by_id(token, chain_id, data)
        if not validation_result.all_passed:
            return ChainRunProgress.from_validation_failure(chain_id, data, validation_result)

        # run chain
        correlation = Correlation(business_context = business_context) # capture passed refs; use new correlation id
        result = self.__api.run_chain_by_id(token, chain_id, data, security_groups, correlation)
        return ChainRunProgress.from_run_output(chain_id, data, result)

    def resolve_contexts(self,
        token: str, chain_id: str,
        raw_inputs: List[Union[RawDatum, Datum]], pre_set_contexts: List[ContextPath],
        mappers: List[ResponseMapper] = None
    ) -> ChainRunProgress:
        """Attempts to resolve the chain's contexts with the contexts provided. Any resolved values are combined with
           the raw inputs to give a set of consolidated inputs, and this is checked for completeness.

           Since the resolving may not complete with the given contexts, and the input set may be insufficient
           a ChainRunProgress is returned, indicating if the requirements are fulfilled - if they are the returned data is
           ready for validation; if they are not the missing inputs are listed.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            pre_set_contexts: List[ContextPath] -- The list of selected contexts to apply to context resolving
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned

        Returns:
            ChainRunProgress - a helper class that gives information about the progress

        Errors:
            ChainNotFound - if chain ID is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        if mappers is None:
            mappers = []

        # initialise mapper
        mapper_set = ResponseMapperSet(mappers)

        # assemble inputs from raw data passed
        data = self.get_data_from_raw_inputs(raw_inputs)

        # get the model requirements
        requirements = self.get_chain_requirements(token, chain_id)
        needed_inputs = requirements.input_definitions

        # capture those we already have responses for
        prepared_inputs: Set[Datum] = set()
        for ni in needed_inputs:
            for datum in (d for d in data if d.datum_key == ni.datum_key):
                prepared_inputs.add(datum)

        # update the inputs still needed
        needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
        new_contexts: Union[ApplicableContext, None]
        if len(needed_inputs) > 0:

            # try to resolve some more values with the contexts we have been given - if any unresolved
            contexts = requirements.applicable_context
            if contexts and not contexts.fully_resolved:

                # set context paths on needed contexts that match pre-set contexts
                for input_context in (ic for ic in contexts.input_contexts if ic.resolved_response is None):
                    if input_context.needed_contexts is not None:
                        for nc in input_context.needed_contexts:
                            for pc in pre_set_contexts:
                                if (pc.context_key == nc.context_key):
                                    input_context.add_path(pc.context_key, pc.context_value_keys)

                # make the API call with these contexts
                new_contexts = self.resolve_input_contexts(token, contexts)

                # add the inputs we now have values for
                for ni in needed_inputs:
                    mapper = mapper_set.get_mapper_for_input(ni)
                    for input_context in (ic for ic in new_contexts.input_contexts if ic.datum_key == ni.datum_key and ic.resolved_response is not None):
                        if input_context.resolved_response is not None:
                            prepared_inputs.add(self.map_from_resolved_value(input_context.resolved_response, input_context.datum_key, ni, mapper))

                # update the inputs still needed
                needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
            else:
                new_contexts = contexts

        if len(needed_inputs) > 0:

            # finally see if there are any inputs we can auto provide
            # there is nothing more we can do for singular inputs
            # but if they are arrays we can add an empty array if the validation allows it
            for ni in needed_inputs:
                if (
                    ni.requirement.is_required(list(prepared_inputs))
                    and ni.data_definition.container_definition.container_type == ContainerType.ARRAY
                    and ni.display_definition.validation_rule is not None
                    and ni.display_definition.validation_rule.not_empty
                ):
                    array_content = self.get_empty_array_content(ni.data_definition.data_type)
                    prepared_inputs.add(Datum(
                        ni.datum_key,
                        Response(
                            container_type=ContainerType.ARRAY,
                            data_type=ni.data_definition.data_type,
                            source="Added by Simplified SDK",
                            unit=ni.data_definition.expected_unit,
                            array_response_content=array_content
                        )
                    ))

        # collate missing required inputs
        needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
        missing_inputs = list(filter(lambda ni: ni.requirement.is_required(list(prepared_inputs)), needed_inputs))

        # return appropriate progress
        if new_contexts and not new_contexts.fully_resolved:
            return ChainRunProgress.from_resolve_failure(chain_id, list(prepared_inputs), new_contexts)
        if len(missing_inputs) > 0:
            missing_keys = list(map(lambda mi: mi.datum_key, missing_inputs))
            return ChainRunProgress.from_unfulfilled_requirements(chain_id, list(prepared_inputs), missing_keys)
        return ChainRunProgress.from_inputs_ready(chain_id, list(prepared_inputs))

    def get_mermaid_graph_for_chain(self,
        token: str, chain_id: str
    ) -> str:
        """Turns the chain adjacency list into a graph MD that Mermaid will render.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The chain ID

        Returns:
            str - the string representation in Mermaid format

        Errors:
            ChainNotFound - if chain ID is not found
            AuthNotValid - if token is invalid
        """

        # Get chain definition and extract inputs, outputs and adjacency list
        saved_chain_definition = self.get_chain_definition(token, chain_id)
        chain_def = saved_chain_definition.chain_definition
        chain_inputs = chain_def.input_definitions
        chain_outputs = chain_def.output_definitions
        adj_list = chain_def.adjacency_list

        # Init Mermaid string list that will be returned by the function
        md = []
        md.append("Visualise at https://mermaid-js.github.io/mermaid-live-editor/")
        md.append("graph LR")

        # because this is a rendering of the adjacency list, and real model 
        # names can get long, we use number to refer to nodes, so as to keep 
        # the output concise.

        key_indexes: Dict[str, str] = {}
        for node in adj_list:
            first_definition = False
            if node not in key_indexes:
                key_indexes[node] = f"{len(key_indexes)}"
                first_definition = True

            node_entry = key_indexes[node]

            # only name node first time we use it
            if first_definition:
                # pick out chain inputs: render in a smaller circle
                input_node = list(filter(lambda i: i.datum_key.to_hash_key() == node, chain_inputs))
                info(input_node)
                if len(input_node) > 0:
                    node_entry = f"{node_entry}(({input_node[0].datum_key.business_key}))"
                else:
                    # rounded rectangle
                    node_entry = f"{node_entry}({node})"
                    
            output_index = 0
            for v in adj_list[node]:
                output_index += 1
                first_definition = False

                if v not in key_indexes:
                    key_indexes[v] = f"{len(key_indexes)}"
                    first_definition = True

                vert_entry = key_indexes[v]

                # only name node first time we use it
                if first_definition:
                    # pick out chain outputs: render in a smaller circle
                    node_output = list(filter(lambda o: o.datum_key.to_hash_key() == v, chain_outputs))
                    if len(node_output) > 0:
                        vert_entry = f"{vert_entry}(({node_output[0].datum_key.business_key}))"
                    else:
                        # rounded rectangle
                        vert_entry = f"{vert_entry}({v})"

                if output_index > 1:
                    # if we are on a second output node
                    # then we don’t need a full node entry
                    md.append(f" {key_indexes[node]} --> {vert_entry}")
                else:
                    md.append(f" {node_entry} --> {vert_entry}")

        return "\n".join(md)
