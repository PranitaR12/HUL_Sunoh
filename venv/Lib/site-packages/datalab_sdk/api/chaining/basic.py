from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping

import requests
from marshmallow import ValidationError
from marshmallow_dataclass import class_schema

from datalab_sdk.api.exceptions import * # want to make easy import for clients of SDK
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)
# import the likely types so clients don't need to know where to find them
from datalab_sdk.api.chaining.exceptions import *
from datalab_sdk.api.chaining.types.requests.try_to_assemble_chain import TryToAssembleChain
from datalab_sdk.api.chaining.types.requests.create_chain import CreateChain
from datalab_sdk.api.chaining.types.requests.check_chain_inputs_by_id import CheckChainInputsById
from datalab_sdk.api.chaining.types.requests.run_chain_by_id import RunChainById
from datalab_sdk.api.chaining.types.responses.assembly_result import AssemblyResult
from datalab_sdk.api.chaining.types.responses.create_chain_output import CreateChainOutput
from datalab_sdk.api.chaining.types.responses.saved_chain_definition import SavedChainDefinition
from datalab_sdk.api.chaining.types.responses.chain_requirements import ChainRequirements
from datalab_sdk.api.chaining.types.responses.run_chain_output import RunChainOutput
from datalab_sdk.api.chaining.types.responses.chain_outputs import ChainOutputs
from datalab_sdk.api.chaining.types.shared.chain_definition import ChainDefinition
from datalab_sdk.api.mme.exceptions import *
from datalab_sdk.api.mme.types.requests.model_reference import FixedModelReference
from datalab_sdk.api.mme.types.requests.resolve_input_contexts import ResolveInputContexts
from datalab_sdk.api.mme.types.requests.applicable_context import ApplicableContext
from datalab_sdk.api.mme.types.requests.correlation import Correlation
from datalab_sdk.api.mme.types.responses.input_validation_result import InputsValidationResult
from datalab_sdk.api.mme.types.shared.enums import ModelState
from datalab_sdk.api.common.schema import CamelCaseSchema
from datalab_sdk.api.mme.types.shared.datum import DatumKey, Response, Datum
from datalab_sdk.api.mme.types.shared.response import * # want to make easy import for clients of SDK
from datalab_sdk.api.mme.types.shared.enums import *

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")

SYSTEM_AUTH_HEADER = "X-ASSOCIATED-SYSTEM-ID"
SYSTEM_USER_HEADER = "X-ASSOCIATED-USER-ID"


class ChainingBasicClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

    def try_to_assemble_chain(
        self, token: str, models_to_chain: List[FixedModelReference], min_level: ModelState
    ) -> AssemblyResult:
        """Attempt to build a valid chain from the specified set of models.

        Arguments:
            token: str -- The auth token to use for the API call
            models_to_chain: List[FixedModelReference] -- The array of fixed model references that should be in the chain.
                Not assumed to be ordered since ordering will come from the chaining process.
            min_level: ModelState -- minimum state that is expected for models to be part of the resulting chain.
                This ensures a known level of trust is respected.

        Returns:
            AssemblyResult -- result of the attempt to chain, including the chain definition if successful, and the error messages if not

        Errors:
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="tryToAssembleChain",
            token=token,
            data=TryToAssembleChain(models_to_chain, min_level),
            input_class=TryToAssembleChain,
            output_class=AssemblyResult
        )

    def create_chain(
        self, token: str, description: str, version: str, chain_definition: ChainDefinition
    ) -> CreateChainOutput:
        """Create a chain from the ChainDefinition.

        Arguments:
            token: str -- The auth token to use for the API call
            description: str -- the description of the chain, should have a business meaning 
                to help users understand the purpose of the chain in other contexts
            version: str -- version given to the chain by the client who can use 
                any value that makes sense to their use case
            chain_definition: ChainDefinition -- definition of the chain to create,
                could be found in the output of tryToAssembleChain

        Returns:
            CreateChainOutput -- string id of the created chain, to be retained by the system client
                because it isn’t possible to find it again with API calls

        Errors:
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="createChain",
            token=token,
            data=CreateChain(description, version, chain_definition),
            input_class=CreateChain,
            output_class=CreateChainOutput
        )

    def get_chain_definition_by_id(
        self, token: str, chain_id: str
    ) -> SavedChainDefinition:
        """Retrieve the definition of the specified chain.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- the unique id the chain was given when created

        Returns:
            SavedChainDefinition -- contains chain definition plus chain id, description and version

        Errors:
            ChainNotFound - if chain id is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_get(
            path="getChainDefinitionById",
            token=token,
            argument=chain_id,
            output_class=SavedChainDefinition,
            not_found=lambda x: ChainNotFound(chain_id, x),
        )

    def delete_chain_by_id(
        self, token: str, chain_id: str
    ):
        """Delete the specified chain.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- the unique id the chain was given when created

        Returns:
            No response body and 200 success code, calling with a non-existent id isn’t an error 

        Errors:
            AuthNotValid - if token is invalid
        """

        self.__request_delete(
            path="deleteChainById",
            token=token,
            argument=chain_id
        )

    def get_chain_requirements_by_id(
        self, token: str, chain_id: str
    ) -> ChainRequirements:
        """Retrieve the requirements for running the specified chain.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- the unique id the chain was given when created

        Returns:
            ChainRequirements -- information about the data the chain needs in order to run.

        Errors:
            ChainNotFound - if chain id is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_get(
            path="getChainRequirementsById",
            token=token,
            argument=chain_id,
            output_class=ChainRequirements,
            not_found=lambda x: ChainNotFound(chain_id, x),
        )

    def resolve_input_contexts(
        self, token: str, applicable_context: ApplicableContext,
    ) -> ApplicableContext:
        """Try to resolve applicable contexts into Responses that can be used with a chain

        Arguments:
            token: str -- The auth token to use for the API call
            applicable_context: ApplicableContext -- The current definition of contexts that apply
                and the context paths that are currently applied

        Returns:
            ApplicableContext - updated definition of contexts that apply, with any values that have been resolved

        Errors:
            InputNotValid - if applicable_context not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="resolveInputContexts",
            token=token,
            data=ResolveInputContexts(applicable_context),
            input_class=ResolveInputContexts,
            output_class=ApplicableContext
        )

    def check_inputs_by_id(
        self, token: str, chain_id: str, data: List[Datum],
    ) -> InputsValidationResult:
        """Check if the specified inputs amount to a valid call of the specified chain

        Arguments:
            token: str -- The auth token to use for the API call
            chain_id: str -- The id of the chain to address
            data: List[Datum] -- The list of Datum defining the input values to check

        Returns:
            InputsValidationResult - details of the validation results for each provided input

        Errors:
            ChainNotFound - if chain id is not found
            InputNotValid - if data not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="checkChainInputsReady",
            token=token,
            data=CheckChainInputsById(chain_id, data),
            input_class=CheckChainInputsById,
            output_class=InputsValidationResult,
            not_found=lambda x: ChainNotFound(chain_id, x),
        )

    def run_chain_by_id(
        self, token: str, chain_id: str, data: List[Datum], security_groups: List[str],
        correlation: Correlation,
    ) -> RunChainOutput:
        """Attempt to run the specified chain, using the provided inputs.

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the chain to address
            data: List[Datum] -- The list of Datum defining the input values to use
            security_groups: List[str] -- The security groups that apply to the run - typically taken from any resolved inputs
            correlation: Correlation -- The definition of run context to connect to wider business work flows

        Returns:
            RunChainOutput - details of the result of the chain run, including provenance details and results
                plus list of models that couldn’t be run

        Errors:
            ChainNotFound - if chain id is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="runChainById",
            token=token,
            data=RunChainById(chain_id, data, security_groups, correlation),
            input_class=RunChainById,
            output_class=RunChainOutput,
            not_found=lambda x: ChainNotFound(chain_id, x)
        )

    def get_model_run_ids_by_chain_run_id(
        self, token: str, chain_run_id: str
    ) -> List[str]:
        """Retrieve the ids of model runs that were associated with a specific chain run.

        Arguments:
            token: str -- The auth token to use for the API call
            chain_run_id: str -- the unique id the chain run (returned in response when a chain was run)

        Returns:
            List[str] -- array of string model run ids

        Errors:
            ChainRunNotFound - if chain run id is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_get_list(
            path="getModelRunIdsByChainRunId",
            token=token,
            argument=chain_run_id,
            not_found=lambda x: ChainRunNotFound(chain_run_id, x)
        )

    def __request_post(
        self, path: str, token: str, data: INPUT_CLASS,
        input_class: Type[INPUT_CLASS], output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        input_schema = class_schema(input_class, base_schema=CamelCaseSchema)
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)

        # prepare input body - may be invalid
        try:
            body = input_schema().dump(data)
            info(body)
        except Exception as err:
            debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        # make call
        url = EnvironmentConfig.get_chaining_api_url(self._environment, path)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.post(url, token, body))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert MME specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    def __request_get(
        self, path: str, token: str, argument: str,
        output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)

        # make call
        url = EnvironmentConfig.get_chaining_api_get_url(self._environment, path, argument)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert MME specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    def __request_get_list(
        self, path: str, token: str, argument: str,
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> List[str]:
        # make call
        url = EnvironmentConfig.get_chaining_api_get_url(self._environment, path, argument)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert MME specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # return json output, it is a list of strings
        run_ids_list = cast(List[str], response)
        info(run_ids_list)
        return run_ids_list

    def __request_delete(
        self, path: str, token: str, argument: str
    ):

        # make call
        url = EnvironmentConfig.get_chaining_api_get_url(self._environment, path, argument)

        # no output from this call
        self.delete(url, token)
