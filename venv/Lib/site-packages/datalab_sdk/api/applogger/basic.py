from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping, Optional, cast

import requests
from marshmallow import ValidationError
from marshmallow_dataclass import class_schema

# want to make easy import for clients of SDK
from datalab_sdk.api.exceptions import *
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)

# import the likely types so clients don't need to know where to find them
from datalab_sdk.api.applogger.exceptions import *
from datalab_sdk.api.applogger.types.basic_metadata import (
    AppLogRequest, AppLogResult, BuildLogResult
)
from datalab_sdk.api.common.schema import CamelCaseSchema

# want to read query paramaters
from flask import request
from datalab_sdk.logger import logger

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")


class BasicAppLoggerClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

################################################################################
# ENDPOINTS
################################################################################

    def fetch_app_log(
        self, 
        token: str, 
        tool_id: str,
        req_data: AppLogRequest
    ) -> AppLogResult:
        """Fetches the app logs for specific tool id and tool version id based on filters.

        Arguments:
            token: str -- The auth token to use for the API call.
            tool_id: str -- Tool Id of the tool for which app logs are required
            req_data: AppLogRequest -- Additional request info that needs to be provided to fetch app logs. This includes tool version along with other filters  

        Returns:
            AppLogResult -- App logs for specified tool id and tool version based on filters provided as part of request info

        Errors:
            AuthNotValid - If token is invalid.
        """

        return self.__request_post(
            path="app-logs",
            arg=tool_id,
            token=token,
            data=req_data,
            input_class=AppLogRequest,
            not_found=None
        )
    
    def fetch_build_log(
        self, 
        token: str, 
        tool_id: str,
        tool_version_id: str
    ) -> BuildLogResult:
        """Fetches the build logs for specific tool id and tool version id.

        Arguments:
            token: str -- The auth token to use for the API call.
            tool_id: str -- Tool Id of the tool for which app logs are required
            tool_version_id: AppLogRequest -- Additional request info that needs to be provided to fetch app logs. This includes tool version along with other filters  

        Returns:
            AppLogResult -- App logs for specified tool id and tool version based on filters provided as part of request info

        Errors:
            AuthNotValid - If token is invalid.
        """
        build_log_arg = tool_id + '?ToolVersionId=' + tool_version_id
        return self.__request_post(
            path="build-logs",
            arg=build_log_arg,
            token=token,
            data=None,
            input_class=None,
            not_found=None
        )

################################################################################
# HELPERS
################################################################################

    def __request_post(
        self, 
        path: str, 
        arg: str,
        token: str,
        data: INPUT_CLASS,
        input_class: Optional[Type[INPUT_CLASS]], 
        not_found: Union[Callable[[str], ResourceNotFound], None] = None,
    ) -> Any:
        body: Dict[Any, Any] = {}
        if(data == None):
            body = {}
        else:
            if(input_class == None):
                input_schema = class_schema(input_class, base_schema=CamelCaseSchema)

                # prepare input body - may be invalid
                try:
                    body = input_schema().dump(data)
                    info(body)
                except Exception as err:
                    logger.debug(err)
                    debug(err)
                    raise InputNotValid("The provided body data did not match expected content for this API call")

        # make call
        url = EnvironmentConfig.get_app_logger_api_url(self._environment, path, arg)

        #Â Special case where we don't expect a response
        
        try:
            response = self.post(url, token, body, parse_response=False)
            print("Response Here: ", response)
        except LogNotFound as err:
            if not_found is not None:
                # Convert tool-session specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.post(url, token, body))
        except Exception as err:
            raise err

        # prepare outputs
        info(response)
        print("Final Response Here: ", response)
        try:
            return response
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)
