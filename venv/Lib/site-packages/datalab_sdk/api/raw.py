import jwt
import requests
from requests.models import CaseInsensitiveDict
from datalab_sdk.api.exceptions import *
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)
from enum import Enum
from logging import info, debug
from typing import Union, Mapping, Any, Iterable
from json.decoder import JSONDecodeError
from requests_toolbelt import MultipartEncoder


PROV_CORR_ID_HEADER = 'x-prov-corr-id'
PROV_CORR_ID_JWT_FIELD = 'ProvenanceId'

class ProvenanceCache:
    # Encapsulate cacheing logic of provenance correlation ids
    #  Designed to be inherited by clients
    def __init__(self):
        self._cached_prov_corr_id  = None

    def _cache_response(self, headers: CaseInsensitiveDict):
        if PROV_CORR_ID_HEADER in headers:
          self._cached_prov_corr_id = headers[PROV_CORR_ID_HEADER]

    def get_provenance_session_id(self, token: str) -> Union[str, None]:
        """Return the Provenance Correlation Id of this session

        Arguments:
            token: str -- The auth token of the current session

        Returns:
            Union[str,None] - the current Provenance Correlation Id, or None
                if there is None present on the token and noe hasn't been
                cached yet
        """
        # A provenance correlation Id in the JWT takes precendence
        # If that's not present we fall back on any Id cached from previous responses
        parsed_token = jwt.decode(token, algorithms=["HS256"], options={"verify_signature": False})
        if PROV_CORR_ID_JWT_FIELD in parsed_token:
          return parsed_token[PROV_CORR_ID_JWT_FIELD]
        elif self._cached_prov_corr_id is not None:
          return self._cached_prov_corr_id
        else:
          return None


BodyType = Union[Mapping[str, Any], Iterable[Mapping[str, Any]]]
JSONResponseType = Union[Mapping[str, Any], Iterable[Mapping[str, Any]]]
ResponseType = Union[requests.Response, JSONResponseType]

class RawClient(ProvenanceCache):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__()
        self._environment = environment

    def __get_error_type_for_status_code(self,  status_code : int):
          if status_code >= 502 and status_code <= 504:
              return TemporaryError
          elif status_code >= 500:
              return InternalError
          elif status_code == 404:
              return ResourceNotFound
          elif status_code == 401:
              return AuthNotValid
          elif status_code >= 400:
              return InputNotValid
          else:
              return APIChanged

    def __raise_error_on_failure(self, r: requests.Response ):
        # Produce an appropriate error type, populated with
        # correlationId and response message if possible.
        if r.status_code >= 300:
            correlation_id = None
            message = r.text
            try:
                json_response = r.json()
                if "correlationId" in json_response:
                      # capture correlation if present
                      correlation_id = json_response["correlationId"]
                if "message" in json_response:
                      # capture message if present
                      message = json_response["message"]
                if "Errors" in json_response:
                    # capture list of errors if present
                    message = "\n".join(json_response["Errors"])
            except JSONDecodeError:
                pass

            errType = self.__get_error_type_for_status_code(r.status_code)
            raise errType(message, correlation_id, r.status_code)


    def __make_request_sequence(self,
    request_verb: str, url: str, token: str, parse_json: bool,
    json: BodyType = None, data: bytes = None,
    additional_headers: Union[dict, None] = None,
    stream: bool = False
    ) -> ResponseType:
        # Generic sequence of operations for any request type
        # Specific cases for users are defined below
        headers = EnvironmentConfig.get_headers(self._environment, token)
        if additional_headers is not None:
            if isinstance(headers, str) and headers == "":
                headers = additional_headers
            elif isinstance(headers, dict):
                headers.update(additional_headers)
        info(f"{request_verb} to {url}")
        if json is not None:
            info(f"body: {json}")
        debug(headers)
        r = requests.request(request_verb, url, headers=headers, json=json, data=data, stream=stream)
        info(f"Response: {r}")
        self._cache_response(r.headers)
        self.__raise_error_on_failure(r)
        if parse_json:
            try:
                return r.json()
            except JSONDecodeError:
                intro = "Received OK status code but could not parse response."
                desc = f"Received body: {r.text}"
                raise APIChanged(f"{intro}\n{desc}", None, 500)
        else:
            return r

    def post(
        self, url: str, token: str, body: BodyType, parse_response: bool = True
    ) -> ResponseType:
        """Make a POST request to the User Apps API
        Arguments:
            url: str -- The full request URL
            token: str -- The auth token to use for the API call
            body: JSON data for the request
            parse_response: bool -- shoudl the response be parsed as JSON
        Returns:
            JSON response data

        Errors:
            APIError - various types representing the class of issue
        """
        return self.__make_request_sequence("POST", url, token, parse_response, json=body )

    def get(
        self, url: str, token: str, parse_response: bool = True, stream: bool = False
    ) -> ResponseType:
        """Make a GET request to the User Apps API
        Arguments:
            url: str -- The full request URL, including any request parameters
            token: str -- The auth token to use for the API call
            parse_response: bool -- should the response be parsed as JSON
            stream: bool - should the response be streamed
        Returns:
            JSON response data

        Errors:
            APIError - various types representing the class of issue
        """
        return self.__make_request_sequence("GET", url, token, parse_response, stream = stream)

    def put(
        self, url: str, token: str, body: BodyType, parse_response: bool = True
    ) ->  ResponseType:
        """Make a PUT request to the User Apps API
        Arguments:
            url: str -- The full request URL
            token: str -- The auth token to use for the API call
            body: JSON data for the request
            parse_response: bool -- shoudl the response be parsed as JSON
        Returns:
            JSON response data

        Errors:
            APIError - various types representing the class of issue
        """
        return self.__make_request_sequence("PUT", url, token, parse_response, json=body)

    def delete(self, url: str, token: str, parse_response: bool = True
    ) ->  ResponseType:
        """Make a DELETE request to the User Apps API
        Arguments:
            url: str -- The full request UR
            token: str -- The auth token to use for the API call
            parse_response: bool -- shoudl the response be parsed as JSON
        Returns:
            No response body

        Errors:
            APIError - various types representing the class of issue
        """
        return self.__make_request_sequence("DELETE", url, token, parse_response, None)

    def multipart_post(self, url: str, token: str, fields : Mapping[str, Any], parse_response: bool = True):
        """Make a multipart POST request to the User Apps API
        Arguments:
            url: str -- The full request URL
            token: str -- The auth token to use for the API call
            fields: Mapping of key->form items
            parse_response: bool -- shoudl the response be parsed as JSON
        Returns:
            JSON response data

        Errors:
            APIError - various types representing the class of issue
        """
        m = MultipartEncoder(fields = fields)
        additional_headers = {
            "Content-Type": m.content_type
        }
        return self.__make_request_sequence("POST", url, token, parse_response, data=m, additional_headers=additional_headers )

    def multipart_put(self, url: str, token: str, fields : Mapping[str, Any], parse_response: bool = True):
        """Make a multipart PUT request to the User Apps API
        Arguments:
            url: str -- The full request URL
            token: str -- The auth token to use for the API call
            fields: Mapping of key->form items
            parse_response: bool -- shoudl the response be parsed as JSON
        Returns:
            JSON response data

        Errors:
            APIError - various types representing the class of issue
        """
        m = MultipartEncoder(fields = fields)
        additional_headers = {
            "Content-Type": m.content_type
        }
        return self.__make_request_sequence("PUT", url, token, parse_response, data=m, additional_headers=additional_headers )

