from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping, Optional, cast

import requests
from marshmallow import ValidationError
from marshmallow_dataclass import class_schema

# want to make easy import for clients of SDK
from datalab_sdk.api.exceptions import *
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)

# import the likely types so clients don't need to know where to find them
from datalab_sdk.api.tool_session.exceptions import *
from datalab_sdk.api.tool_session.types.basic_metadata import (
    SessionContext,
    SnapshotOutput,
    RegisterSnapshotRequest,
    ResultsViewUrl,
)
from datalab_sdk.api.common.schema import CamelCaseSchema

# want to read query paramaters
from flask import request
from datalab_sdk.logger import logger

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")


class ToolSessionBasicClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

################################################################################
# ENDPOINTS
################################################################################

    def get_context_by_session_id(
        self, 
        token: str, 
        session_id: str,
    ) -> SessionContext:
        """Gets the tool session context, describing how the run the tool for that session.

        Arguments:
            token: str -- The auth token to use for the API call.
            session_id: str -- Id of the tool session to get the context for.

        Returns:
            SessionContext -- Information about the context of the session, including the inputs.

        Errors:
            AuthNotValid - If token is invalid.
            SessionNotFound - If the session id is not found in the database.
        """

        return self.__request_get(
            path="context",
            token=token,
            argument=session_id,
            output_class=SessionContext,
            not_found=lambda x: SessionNotFound(session_id, x)
        )

    def register_snapshot(
        self, 
        token: str, 
        session_id: str,
        has_completed: bool,
        was_successful: bool,
        outputs: List[SnapshotOutput],
        timestamp: str,
    ) -> ResultsViewUrl:
        """Registers the outputs for a snapshot of a tool session, along with the current status of that session.

        Arguments:
            token: str -- The auth token to use for the API call.
            session_id: str -- Id of the tool session to register the snapshot against.
            has_completed: bool -- Value indicating whether the session is now complete.
                Set this to False if you expect the user to register further snapshots.
            was_successful: bool -- Value indicating whether the tool ran successfully.
                For example, it would be False if a recipe was input and it was not compatible.
            outputs: List[SnapshotOutput] -- References to each output to associate with this snapshot.
            timestamp: str -- Date and time when the result was calculated/generated. Free format.

        Returns:
            ResultsViewUrl -- URL for the app to redirect the user to for viewing of the results in the UI.

        Errors:
            AuthNotValid - If token is invalid.
            SessionNotFound - If the session id is not found in the database.
        """

        return self.__request_post(
            path="registerSnapshot",
            token=token,
            data=RegisterSnapshotRequest(session_id, has_completed, was_successful, outputs, timestamp),
            input_class=RegisterSnapshotRequest,
            output_class=ResultsViewUrl,
            not_found=lambda x: SessionNotFound(session_id, x)
        )

################################################################################
# HELPERS
################################################################################

    def __request_get(
        self, path: str, token: str, argument: str,
        output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)

        # make call
        url = EnvironmentConfig.get_tool_session_api_url(self._environment, path, argument)

        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token))
        except ResourceNotFound as err:
            logger.debug(err)
            if not_found is not None:
                # Convert tool-session specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    def __request_post(
        self, 
        path: str, 
        token: str, 
        data: INPUT_CLASS,
        input_class: Type[INPUT_CLASS], 
        output_class: Optional[Type[OUTPUT_CLASS]],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None,
    ) -> OUTPUT_CLASS:
        input_schema = class_schema(input_class, base_schema=CamelCaseSchema)

        # prepare input body - may be invalid
        try:
            body = input_schema().dump(data)
            info(body)
        except Exception as err:
            logger.debug(err)
            debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        # make call
        url = EnvironmentConfig.get_tool_session_api_url(self._environment, path, "")

        # Special case where we don't expect a response
        if output_class is None:
            try:
                response = self.post(url, token, body, parse_response=False)
            except ResourceNotFound as err:
                logger.debug(err)
                if not_found is not None:
                    # Convert tool-session specific errors
                    raise not_found(err.correlation_id)
                else:
                    raise err
            return cast(OUTPUT_CLASS, None)

        # Otherwise, handle output schema
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)
        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.post(url, token, body))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert tool-session specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)
