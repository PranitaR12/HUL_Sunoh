from datalab_sdk.api.mme.types.responses.input_validation_result import InputValidationResult
from datalab_sdk.api.mme.basic import (
    RunOutput,
    ApplicableContext,
    RunStatus,
    Security,
    InputsValidationResult,
    InputDefinition,
    Response,
    DataType,
    ContainerType,
    Unit,
    SingularResponseContent,
    ArrayResponseContent
)
from datalab_sdk.api.mme.types.responses.result import Result
from datalab_sdk.api.mme.types.responses.model_run_progress import ModelRunProgress
from datalab_sdk.api.mme.types.shared.datum import RawValue, DatumKey, Datum
from typing import Tuple, Union, List
from dataclasses import dataclass
from datalab_sdk.api.mme.types.shared.unit import Unit


@dataclass
class RawDatum:
    datum_key: DatumKey
    value: RawValue
    unit: Union[Unit, None] = None
    source: Union[None, str] = None
    timestamp: Union[None, str] = None
    security: Union[None, Security] = None


@dataclass
class RunProgress:
    model_id: str
    contexts_resolved: bool
    requirements_fulfilled: bool
    inputs_valid: bool
    has_run: bool
    run_output: Union[RunOutput, None] = None
    validation_result: Union[InputsValidationResult, None] = None
    inputs: Union[List[Datum], None] = None
    missing_inputs: Union[List[DatumKey], None] = None
    context: Union[ApplicableContext, None] = None
    class_two_progress: Union[ModelRunProgress, None] = None


    __status_map = {
        RunStatus.SUCCESS: "Model completed successfully using inputs - see run_output for results",
        RunStatus.FAILURE: "Model failed to run with inputs - see run_output for errors",
        RunStatus.NOT_AVAILABLE: "Model was not run as it could not be found in MME",
        RunStatus.NULL_RUN_STATUS: "Model was not run as inputs were invalid"
    }


    @property
    def successfully_completed(self) -> bool:
        """True if the model was run and returned success"""
        return self.has_run and self.run_output is not None and self.run_output.run_status == RunStatus.SUCCESS


    def get_summary(self) -> str:
        """Gives a summary of the run"""
        summary: str = ""
        if self.has_run and self.run_output is not None:
            summary = self.__status_map[self.run_output.run_status]
        elif self.inputs_valid:
            summary =  "Model not run yet, but required inputs are provided and ready for checking"
        else:
            if not self.contexts_resolved:
                summary =  "Model was not run as applicable contexts were fully not resolved - see context for details, and inputs for latest input set"
            elif not self.requirements_fulfilled:
                summary =  "Model was not run with inputs as required inputs were missing - see missing_inputs for details"
            else:
                summary =  "Model was not run as inputs were not valid - see validation_result for details"

        return summary


    def get_result_by_key(self, key: DatumKey) -> Union[Result, None]:
        """Retrieves the model result with the passed key - or None if not found"""
        found_result: Union[Result, None] = None
        if self.successfully_completed and self.run_output is not None and self.run_output.result_groups is not None:
            for group in self.run_output.result_groups:
                for result in group.results:
                    if result.datum_key == key:
                        found_result = result

        return found_result


    def get_input_by_key(self, key: DatumKey) -> Union[Datum, None]:
        """Retrieves the input with the passed key - or None if not found"""
        found_input: Union[Datum, None] = None
        if self.inputs is not None:
            for input in self.inputs:
                if input.datum_key == key:
                    found_input = input
        return found_input


    def get_raw_result_by_key(self, key: DatumKey) -> Union[RawValue, None]:
        """Returns a RawValue containing the value of the model result with the passed key - or None if not found"""
        result = self.get_result_by_key(key)
        if result is not None:
            if result.response.security is not None and result.response.security.encrypted:
                return "Value redacted for current user"
            else:
                return result.response.to_raw()
        else:
            return None


    @classmethod
    def from_run_output(
        cls, 
        model_id: str, 
        inputs: List[Datum], 
        run_output: RunOutput,
    ):
        return cls(
            model_id, 
            contexts_resolved=True, 
            requirements_fulfilled=True, 
            inputs_valid=True, 
            has_run=True, 
            inputs=inputs, 
            run_output=run_output,
        )


    @classmethod
    def from_validation_failure(cls, model_id: str, inputs: List[Datum], validation_result: InputsValidationResult):
        return cls(model_id, True, True, False, False, inputs=inputs, validation_result=validation_result)


    @classmethod
    def from_inputs_ready(cls, model_id: str, inputs: List[Datum]):
        return cls(model_id, True, True, True, False, inputs=inputs)


    @classmethod
    def from_unfulfilled_requirements(cls, model_id: str, inputs: List[Datum], missing_inputs: List[DatumKey]):
        return cls(model_id, True, False, False, False, inputs=inputs, missing_inputs=missing_inputs)


    @classmethod
    def from_resolve_failure(cls,  model_id: str, inputs: List[Datum], applicable_context: ApplicableContext):
        return cls(model_id, False, False, False, False, inputs=inputs, context=applicable_context)
