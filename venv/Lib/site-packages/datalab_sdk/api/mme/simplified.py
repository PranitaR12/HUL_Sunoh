from datalab_sdk.api.mme.basic import (
    MMEBasicClient,
    Environment,
)
from datalab_sdk.api.mme.simplified_types import (
    RawDatum,
    RunProgress,
)
from datalab_sdk.api.mme.response_mappers import (
    ResponseMapper,
    ResponseMapperSet,
)
from datalab_sdk.api.common.simplified import *
from datalab_sdk.api.mme.basic import * # want to make easy import for clients of SDK
from datalab_sdk.api.mme.types.requests.correlation import Correlation
from datalab_sdk.api.mme.types.requests.context_path import ContextPath
from typing import Union, List, Set
from logging import (
    debug,
    info,
)
from retrying import retry # type: ignore
from uuid import uuid4
import asyncio


# Client specific to a particular class two model run, created by the MMESimplifiedClient
# Placed before the simplified client to satisfy Pylance
class MMEClassTwoModelRunClient():
    def __init__(
        self, 
        api: MMEBasicClient,
        token: str, 
        run_id: str,
        owner: str,
        run_progress: RunProgress,
    ):
        self.__api: MMEBasicClient = api
        self.__token = token
        self.run_id = run_id
        self.owner = owner
        self.run_progress: RunProgress = run_progress
        self.last_status = ClassTwoRunStatus.NULL_RUN_STATUS
        self.last_report = ""


    @classmethod
    def for_just_started(
        cls, 
        api: MMEBasicClient,
        token: str, 
        run_id: str,
        owner: str,
        model_id: str,
        inputs: List[Datum],
    ):
        run_progress = RunProgress.from_inputs_ready(model_id, inputs)
        return cls(
            api,
            token, 
            run_id, 
            owner, 
            run_progress, 
        )


    @classmethod
    def for_validation_failure(
        cls, 
        api: MMEBasicClient,
        model_id: str,
        inputs: List[Datum],
        validation_result: InputsValidationResult,
    ):
        run_progress = RunProgress.from_validation_failure(model_id, inputs, validation_result)
        return cls(
            api,
            "", 
            "", 
            "", 
            run_progress, 
        )


    @classmethod
    def for_unresolved_contexts(
        cls, 
        api: MMEBasicClient,
        run_progress: RunProgress,
    ):
        return cls(
            api,
            "", 
            "", 
            "", 
            run_progress, 
        )


    # --- Wrapper Method ---
    def update_progress(self) -> RunProgress:
        """Checks the progress of this model run, 
           storing the most recent status and progress report message.

        Returns:
            RunProgress -- Helper class that gives information about what happened and aids result retrieval

        Errors:
            AuthNotValid -- if token is invalid
        """
        self.__assert_run_id()

        progress = self.__api.get_model_run_progress(self.__token, self.run_id, self.owner)
        self.run_progress.class_two_progress = progress
        self.last_status = progress.status
        self.last_report = progress.progress[-1].message if len(progress.progress) > 0 else ""
        
        if self.has_ended(self.run_progress):
            self.run_progress.has_run = True

        # Do some logging as it's useful for the developer to see what's going on
        info(f"Updated progress of run {id}, status: {self.last_status}, progress: {self.last_report}")
        
        return self.run_progress


    # --- Wrapper Method ---
    def cancel(self) -> None:
        """Requests the cancellation of this model run

        Errors:
            AuthNotValid -- if token is invalid
        """
        self.__assert_run_id()

        return self.__api.cancel_model_run(self.__token, self.run_id, self.owner)


    # --- Wrapper Method ---
    def complete(self) -> RunProgress:
        """Completes this run of a model, closing it and returning the results.

        Returns:
            RunProgress -- Helper class that gives information about what happened and aids result retrieval

        Errors:
            AuthNotValid -- if token is invalid
        """
        self.__assert_run_id()
        
        result = self.__api.complete_model_run(self.__token, self.run_id, self.owner)
        info(f"Completed run {self.run_id} for model {self.run_progress.model_id}.")

        if self.run_progress.inputs is None:
            raise TypeError("inputs not provided")

        return RunProgress.from_run_output(self.run_progress.model_id, self.run_progress.inputs, result)


    # --- Wrapper Method ---
    def wait_until_complete(
        self,
        check_interval_seconds: int = 1,
        max_duration_seconds: int = 0,
    ) -> RunProgress:
        """Regularly checks the progress of this run of the model until it is completed,
        then closes it and returns the results.

        Arguments:
            check_interval_seconds: int -- How often to check the run progress, in seconds.
            max_duration_seconds: int -- Number of seconds before abandoning the run. 0 means try forever.

        Returns:
            RunProgress -- A helper class that gives information about what happened and aids result retrieval

        Errors:
            AuthNotValid -- if token is invalid
        """
        def retry_on_any_error(exception):
            return isinstance(exception, Exception)

        @retry(retry_on_exception=retry_on_any_error, wait_fixed=check_interval_seconds*1000, stop_max_delay=max_duration_seconds*1000)
        def check_whether_ended():
            if not self.has_ended(self.update_progress()):
                raise Exception("Run has not ended by max allowed duration.")

        # Retry decorator will cause this to keep polling until completed
        check_whether_ended()
        return self.complete()


    # --- Added Value Method ---
    def has_ended(
        self, 
        progress: RunProgress,
    ):
        """Helper to check from a ModelRunProgress whether the run has ended.

        Arguments:
            progress: RunProgress -- Helper class that gives information about what happened and aids result retrieval

        Returns:
            bool -- True if the run has ended; otherwise, false.
        """
        if progress.class_two_progress is None:
            raise TypeError("class_two_progress not set")

        return progress.class_two_progress.status==ClassTwoRunStatus.ENDED


    def __assert_run_id(self):
        assert self.run_id != "", "run_id not available -- has the class been initialised from a started run?"



# Simplified interface to the API, giving help around the most common use cases.
# Wrapper methods just simplify the interface, while added value methods integrate common actions.
class MMESimplifiedClient(CommonSimplifiedClient):
    def __init__(self, environment: Environment = Environment.PROD):
        CommonSimplifiedClient.__init__(self)
        self.__api = MMEBasicClient(environment=environment)


    # --- Wrapper Method ---
    def get_id_for_model(
        self, 
        token: str, 
        model: Union[str, FixedModelReference],
    ) -> str:
        """Accepts a model reference or id, and resolves (if needed) to a model id"""

        # Find model id if not passed -- if doesn't exist will throw
        if isinstance(model, FixedModelReference):
            return self.get_model_id_from_reference(token, model)
        else:
            return model


    # --- Added Value Method ---
    def get_model_id_from_reference(
        self, 
        token: str,
        model_reference: FixedModelReference,
    ) -> str:
        """Get the id of the model in MME that has the specified reference
           Model references can be used on all simplified methods,
           but it is more efficient to retrive the model id once and use that for subsequent calls.

        Arguments:
            token: str -- The auth token to use for the API call
            model_reference: FixedModelReference -- The fixed reference of the model to address

        Returns:
            str -- The model_id

        Errors:
            ModelNotFound -- if model reference is not found
            AuthNotValid -- if token is invalid
        """

        result = self.check_models_can_be_resolved(token, [model_reference], ModelState.PUBLISHED)
        resolved = result.get_model_result(model_reference)
        if (resolved is None or not resolved.available):
            raise ModelNotFound(str(model_reference))
        return resolved.resolved_id


    # --- Wrapper Method ---
    def get_provenance_session_id(self, token):
        """Return the Provenance Correlation Id of this session

        Arguments:
            token: str -- The auth token of the current session

        Returns:
            Union[str,None] -- the current Provenance Correlation Id, or None
                if there is None present on the token and noe hasn't been
                cached yet
        """
        return self.__api.get_provenance_session_id(token)


    # --- Wrapper Method ---
    def check_models_can_be_resolved(
        self, 
        token: str, 
        models: List[ModelReference], 
        min_state: ModelState = ModelState.PUBLISHED,
        compatible_time_point:str = None
    ) -> ResolveModelResults:
        """Tries to resolve the model references into specific models to run

        Arguments:
            token: str -- The auth token to use for the API call
            models: List[ModelReference] -- List of the model references that should be resolved
            min_state: ModelState = ModelState.PUBLISHED -- optional minimum state that the model must be in to be
                resolved. This defaults to PUBLISHED. The Resolve results will give available state if a model
                fails to resolve due to not meeting the min state.
            compatible_time_point: Timeformat ISO 8601 string (optional parameter)

        Returns:
            ResolveResults -- per-model results of the attempt to resolve.

        Errors:
            AuthNotValid -- if token is invalid
        """

        return self.__api.check_models_can_be_resolved(token, models, min_state, compatible_time_point)


    # --- Wrapper Method ---
    def get_model_requirements(
        self, 
        token: str, 
        model: Union[str, FixedModelReference],
        lookup_contexts: bool = True,
    ) -> ModelRequirements:
        """Find the requirements for running the specified model

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference
            lookup_contexts: bool = True -- optional flag to control if MME should perform the costly operation to
                find contexts that apply to the model inputs. Usually this is needed, but not always

        Returns:
            ModelRequirements -- full definition of requirements to run the model

        Errors:
            ModelNotFound -- if model is not found
            AuthNotValid -- if token is invalid
        """
        if isinstance(model, FixedModelReference):
            return self.__api.get_model_requirements_by_reference(token, model, lookup_contexts )
        else:
            return self.__api.get_model_requirements_by_id(token, model, lookup_contexts )


    # --- Wrapper Method ---
    def get_model_outputs(
        self, 
        token: str, 
        model: Union[str, FixedModelReference],
    ) -> ModelOutputs:
        """Get the definition of the outputs the model will return

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference

        Returns:
            ModelOutputs -- full definition of outputs the model will returns

        Errors:
            ModelNotFound -- if model is not found
            AuthNotValid -- if token is invalid
        """
        return self.__api.get_model_outputs_by_id(token, self.get_id_for_model(token, model))


    # --- Wrapper Method ---
    def resolve_input_contexts(
        self, 
        token: str, 
        applicable_context: ApplicableContext,
    ) -> ApplicableContext:
        """Try to resolve applicable contexts into Responses that can be used with a model

        Arguments:
            token: str -- The auth token to use for the API call
            applicable_context: ApplicableContext -- The current definition of contexts that apply
                and the context paths that are currently applied

        Returns:
            ApplicableContext -- updated definition of contexts that apply, with any values that have been resolved

        Errors:
            InputNotValid -- if applicable_context not specified correctly
            AuthNotValid -- if token is invalid
        """
        return self.__api.resolve_input_contexts(token, applicable_context)


    # --- Wrapper Method ---
    def check_inputs(
        self, 
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]],
    ) -> InputsValidationResult:
        """Check if the provided inputs are ready to be sent to the model

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to check. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input

        Returns:
            InputsValidationResult -- details of the validation results for each provided input

        Errors:
            ModelNotFound -- if model is not found
            InputNotValid -- if data not specified correctly
            AuthNotValid -- if token is invalid
        """
        # handle input ambiguity
        model_id = self.get_id_for_model(token, model )
        data = self.get_data_from_raw_inputs(raw_inputs)
        return self.__api.check_inputs_by_id(token, model_id, data )


    # --- Added Value Method ---
    def resolve_contexts(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]], 
        pre_set_contexts: List[ContextPath],
        mappers: List[ResponseMapper] = None,
    ) -> RunProgress:
        """Attempts to resolve the model's contexts with the contexts provided. Any resolved values are combined with
           the raw inputs to give a set of consolidated inputs, and this is checked for completeness.

           Since the resolving may not complete with the given contexts, and the input set may be insufficient
           a RunProgress is returned, indicating if the requirements are fulfilled -- if they are the returned data is
           ready for validation; if they are not the missing inputs are listed.

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            pre_set_contexts: List[ContextPath] -- The list of selected contexts to apply to context resolving
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned

        Returns:
            RunProgress -- a helper class that gives information about the progress

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """

        if mappers is None:
            mappers = []

        # initialise mapper
        mapper_set = ResponseMapperSet(mappers)

        # Assemble inputs from raw data passed
        data = self.get_data_from_raw_inputs(raw_inputs)

        # get the model requirements
        if isinstance(model, FixedModelReference):
            requirements = self.__api.get_model_requirements_by_reference(token, model)
        else:
            requirements = self.__api.get_model_requirements_by_id(token, model)
        model_id = requirements.model_definition.model_id
        needed_inputs = self.get_input_set_from_requirements(requirements)

        # capture those we already have responses for
        prepared_inputs: Set[Datum] = set()
        for ni in needed_inputs:
            for datum in (d for d in data if d.datum_key == ni.datum_key):
                prepared_inputs.add(datum)

        # update the inputs still needed
        needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
        new_contexts: Union[ApplicableContext, None]
        if len(needed_inputs) > 0:

            # try to resolve some more values with the contexts we have been given -- if any unresolved
            contexts = requirements.applicable_context
            if contexts and not contexts.fully_resolved:

                # set context paths on needed contexts that match pre-set contexts
                for input_context in (ic for ic in contexts.input_contexts if ic.resolved_response is None):
                    if input_context.needed_contexts is not None:
                        for nc in input_context.needed_contexts:
                            for pc in pre_set_contexts:
                                if (pc.context_key == nc.context_key):
                                    input_context.add_path(pc.context_key, pc.context_value_keys)

                # make the API call with these contexts
                new_contexts = self.resolve_input_contexts(token, contexts)

                # add the inputs we now have values for
                for ni in needed_inputs:
                    mapper = mapper_set.get_mapper_for_input(ni)
                    for input_context in (ic for ic in new_contexts.input_contexts if ic.datum_key == ni.datum_key and ic.resolved_response is not None):
                        if input_context.resolved_response is not None:
                            prepared_inputs.add(self.map_from_resolved_value(input_context.resolved_response, input_context.datum_key, ni, mapper))

                # update the inputs still needed
                needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
            else:
                new_contexts = contexts

        if len(needed_inputs) > 0:

            # finally see if there are any inputs we can auto provide
            # there is nothing more we can do for singular inputs
            # but if they are arrays we can add an empty array if the validation allows it
            for ni in needed_inputs:
                if (
                    ni.requirement.is_required(list(prepared_inputs))
                    and ni.data_definition.container_definition.container_type == ContainerType.ARRAY
                    and ni.display_definition.validation_rule is not None
                    and ni.display_definition.validation_rule.not_empty
                ):
                    array_content = self.get_empty_array_content(ni.data_definition.data_type)
                    prepared_inputs.add(Datum(
                        ni.datum_key,
                        Response(
                            container_type=ContainerType.ARRAY,
                            data_type=ni.data_definition.data_type,
                            source="Added by Simplified SDK",
                            unit=ni.data_definition.expected_unit,
                            array_response_content=array_content
                        )
                    ))

        # collate missing required inputs
        needed_inputs = self.filter_to_missing(needed_inputs, prepared_inputs)
        missing_inputs = list(filter(lambda ni: ni.requirement.is_required(list(prepared_inputs)), needed_inputs))

        # return appropriate progress
        if new_contexts and not new_contexts.fully_resolved:
            return RunProgress.from_resolve_failure(model_id, list(prepared_inputs), new_contexts)
        if len(missing_inputs) > 0:
            missing_keys = list(map(lambda mi: mi.datum_key, missing_inputs))
            return RunProgress.from_unfulfilled_requirements(model_id, list(prepared_inputs), missing_keys)
        return RunProgress.from_inputs_ready(model_id, list(prepared_inputs))


    # --- Wrapper Method ---
    def run_model(
        self, 
        token: str, 
        model: Union[str, FixedModelReference], 
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        class_two_owner: str = None,
        class_two_max_duration_seconds: int = 30,
    ) -> RunOutput:
        """Run the model with the provided inputs. These should have been checked first. Class two models are time-limited.

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions
            class_two_owner: str -- The owner reference for the model run, which can be used to find 
                active class two model runs (e.g. app_id+user_id). May be omitted, in which case a GUID is generated.
                Providing this reference for a class one model will cause the function to fail.
            class_two_max_duration_seconds: int = 30 -- Number of seconds before a class two model will be cancelled.

        Returns:
            RunOutput -- details of the result of the model run, including provenance details and results

        Errors:
            ModelNotFound -- if model is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """
        if security_groups is None:
            security_groups = []

        has_class_two_owner_provided = False
        if class_two_owner is None:
            class_two_owner = str(uuid4())
        else:
            has_class_two_owner_provided = True

        # Create correlation, with passed refs and new correlation id
        data = self.get_data_from_raw_inputs(raw_inputs)
        correlation = Correlation(business_context = business_context)

        # Run model
        # Try as class one first, as we want that to perform as fast as possible
        # If we then find out it's class two, we can run the alternate request, as the caller will expect some wait for class two model results
        # However, if the user provided a class two owner we assume they know they are calling a class two model
        if not has_class_two_owner_provided:
            if isinstance(model, FixedModelReference):
                output = self.__api.run_model_by_reference(token, model, data, security_groups, correlation)
            else:
                output = self.__api.run_model_by_id(token, model, data, security_groups, correlation)
            
            # Trying a class two model as a class one does not error but returns a 'not available' status with empty errors
            if not (output.run_status == RunStatus.NOT_AVAILABLE and output.errors is not None and len(output.errors) == 0):
                return output

        # Try running as a class two model
        if isinstance(model, FixedModelReference):
            run_id_response = self.__api.start_model_run_by_reference(token, model, data, security_groups, correlation, class_two_owner, 1)
        else:
            run_id_response = self.__api.start_model_run_by_id(token, model, data, security_groups, correlation, class_two_owner, 1)
        run_id = run_id_response.run_id
        model_id = str(model) if isinstance(model, FixedModelReference) else model
        info(f"Started run {run_id} for model {model_id}.")

        # Now block until the model has finished its run or we time-out
        run_client = MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, class_two_owner, model_id, data)
        progress = run_client.wait_until_complete(check_interval_seconds=2, max_duration_seconds=class_two_max_duration_seconds)
        if progress.run_output is None:
            raise APIError("Expected run output but found none.")
        
        return progress.run_output


    # --- Added Value Method ---
    def run_with_data(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        class_two_owner: str = None,
        class_two_max_duration_seconds: int = 30,
    ) -> RunProgress:
        """Validates the provided data against a class one or class two model, then runs that model, 
           returning an object which also contains the inputs. Class two models are time-limited.

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions
            class_two_owner: str -- The owner reference for the model run, which can be used to find 
                active class two model runs (e.g. app_id+user_id). May be omitted, in which case a GUID is generated.
                Providing this reference for a class one model will cause the function to fail.
            class_two_max_duration_seconds: int = 30 -- Number of seconds before a class two model will be cancelled.

        Returns:
            RunProgress -- a helper class that gives information about what happened and aids result retrieval

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """
        if security_groups is None:
            security_groups = []

        has_class_two_owner_provided = False
        if class_two_owner is None:
            class_two_owner = str(uuid4())
        else:
            has_class_two_owner_provided = True

        # Find model id
        model_id = self.get_id_for_model(token, model)

        # Assemble inputs from raw data passed
        data = self.get_data_from_raw_inputs(raw_inputs)

        # Validate inputs
        validation_result = self.__api.check_inputs_by_id(token, model_id, data)
        if not validation_result.all_passed:
            return RunProgress.from_validation_failure(model_id, data, validation_result)

        # Capture passed refs; use new correlation id
        correlation = Correlation(business_context = business_context) 

        # Run model
        # Try as class one first, as we want that to perform as fast as possible
        # If we then find out it's class two, we can run the alternate request, as the caller will expect some wait for class two model results
        # However, if the user provided a class two owner we assume they know they are calling a class two model
        if not has_class_two_owner_provided:
            output = self.__api.run_model_by_id(token, model_id, data, security_groups, correlation)
            
            # Trying a class two model as a class one does not error but returns a 'not available' status with empty errors
            if not (output.run_status == RunStatus.NOT_AVAILABLE and output.errors is not None and len(output.errors) == 0):
                return RunProgress.from_run_output(model_id, data, output)

        # Try running as a class two model
        run_id_response = self.__api.start_model_run_by_id(token, model_id, data, security_groups, correlation, class_two_owner, 1)
        run_id = run_id_response.run_id
        info(f"Started run {run_id} for model {model_id}.")

        # Now block until the model has finished its run or we time-out
        run_client = MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, class_two_owner, model_id, data)
        return run_client.wait_until_complete(check_interval_seconds=2, max_duration_seconds=class_two_max_duration_seconds)


    # --- Added Value Method ---
    def run_with_data_and_context(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]], 
        contexts: List[ContextPath],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        mappers: List[ResponseMapper] = None,
        class_two_owner: str = None,
        class_two_max_duration_seconds: int = 30,
    ) -> RunProgress:
        """Uses contexts to resolve inputs that have not been provided for a class one or class two model, 
           and if this is successful, validates the provided data against the model then runs that model, 
           returning an object which also contains the inputs. Class two models are time-limited.

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            contexts: List[ContextPath] -- The list of context paths to use to try to resolve data for the model
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run -- after resolving inputs
                any security groups associated with resolved inputs will be added to the list provided
                May be omitted, which will default to no specific restrictions
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned
            class_two_owner: str -- The owner reference for the model run, which can be used to find 
                active class two model runs (e.g. app_id+user_id). May be omitted, in which case a GUID is generated.
                Providing this reference for a class one model will cause the function to fail.
            class_two_max_duration_seconds: int = 30 -- Number of seconds before a class two model will be cancelled.

        Returns:
            RunProgress -- a helper class that gives information about what happened and aids result retrieval

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """
        if security_groups is None:
            security_groups = []
        if mappers is None:
            mappers = []
            
        has_class_two_owner_provided = False
        if class_two_owner is None:
            class_two_owner = str(uuid4())
        else:
            has_class_two_owner_provided = True

        # resolve model requirements
        resolved_contexts = self.resolve_contexts(token, model, raw_inputs, contexts, mappers)
        if resolved_contexts.model_id is None or resolved_contexts.inputs is None or not resolved_contexts.requirements_fulfilled:
            return resolved_contexts

        model_id = resolved_contexts.model_id
        data = resolved_contexts.inputs

        # Validate inputs
        validation_result = self.__api.check_inputs_by_id(token, model_id, data)
        if not validation_result.all_passed:
            return RunProgress.from_validation_failure(model_id, data, validation_result)
        elif validation_result.warnings is not None and len(validation_result.warnings) > 0:
            debug("Inputs had validation warnings", ",".join(validation_result.warnings))

        ## add security from inputs
        security_groups = self.get_security_groups_associated_with_inputs(data, security_groups)
        
        # Capture passed refs; use new correlation ids
        correlation = Correlation(business_context = business_context) 

        # Run model
        # Try as class one first, as we want that to perform as fast as possible
        # If we then find out it's class two, we can run the alternate request, as the caller will expect some wait for class two model results
        # However, if the user provided a class two owner we assume they know they are calling a class two model
        if not has_class_two_owner_provided:
            output = self.__api.run_model_by_id(token, model_id, data, security_groups, correlation)
            
            # Trying a class two model as a class one does not error but returns a 'not available' status with empty errors
            if not (output.run_status == RunStatus.NOT_AVAILABLE and output.errors is not None and len(output.errors) == 0):
                return RunProgress.from_run_output(model_id, data, output)

        # Try running as a class two model
        run_id_response = self.__api.start_model_run_by_id(token, model_id, data, security_groups, correlation, class_two_owner, 1)
        run_id = run_id_response.run_id
        info(f"Started run {run_id} for model {model_id}.")

        # Now block until the model has finished its run or we time-out
        run_client = MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, class_two_owner, model_id, data)
        return run_client.wait_until_complete(check_interval_seconds=2, max_duration_seconds=class_two_max_duration_seconds)


    # --- Wrapper Method ---
    def start_model_run(
        self, 
        token: str, 
        model: Union[str, FixedModelReference], 
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        owner: str = None, 
        max_duration_days: int = 1,
    ) -> MMEClassTwoModelRunClient:
        """Starts running a class two model with the provided inputs. The inputs should have been checked first.
        It provides an object help with monitoring the new run and obtaining both the inputs and the results. 

        Arguments:
            token: str -- The auth token to use for the API call
            model_reference: FixedModelReference -- The fixed reference of the model to address
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions
            owner: str -- The owner reference for the model run, which can be used to find active model runs (e.g. app_id+user_id)
                May be omitted, in which case a GUID is generated.
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer

        Returns:
            MMEClassTwoModelRunClient -- Helper class that allows the new run to be checked and results to be obtained when ready.

        Errors:
            AuthNotValid -- if token is invalid
            ModelNotFound -- if model id is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
        """
        if security_groups is None:
            security_groups = []
        if owner is None:
            owner = str(uuid4())

        # Create correlation, with passed refs and new correlation id
        data = self.get_data_from_raw_inputs(raw_inputs)
        correlation = Correlation(business_context = business_context)

        if isinstance(model, FixedModelReference):
            run_id_response = self.__api.start_model_run_by_reference(
                token, 
                model, 
                data, 
                security_groups, 
                correlation, 
                owner, 
                max_duration_days)
        else:
            run_id_response = self.__api.start_model_run_by_id(
                token, 
                model, 
                data, 
                security_groups, 
                correlation, 
                owner, 
                max_duration_days)

        # Do some logging as it's useful for the developer to see what's going on
        run_id = run_id_response.run_id
        model_id = str(model) if isinstance(model, FixedModelReference) else model
        info(f"Started run {run_id} for model {model_id}.")

        # Create a client specific to this run, for follow-on operations
        return MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, owner, model_id, data)


    # --- Added Value Method ---
    def start_model_run_with_data(
        self,
        token: str, model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        owner: str = None,
        max_duration_days: int = 1,
    ) -> MMEClassTwoModelRunClient:
        """Validates the provided data against a class two model, then starts running that model. 
           It provides an object help with monitoring the new run and obtaining both the inputs and the results. 

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions
            owner: str -- The owner reference for the model run, which can be used to find active model runs (e.g. app_id+user_id)
                May be omitted, in which case a GUID is generated.
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer

        Returns:
            MMEClassTwoModelRunClient -- Helper class that allows the new run to be checked and results to be obtained when ready.

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """

        if security_groups is None:
            security_groups = []
        if owner is None:
            owner = str(uuid4())

        # Find model id
        model_id = self.get_id_for_model(token, model)

        # Assemble inputs from raw data passed
        data = self.get_data_from_raw_inputs(raw_inputs)

        # Validate inputs
        validation_result = self.__api.check_inputs_by_id(token, model_id, data)
        if not validation_result.all_passed:
            return MMEClassTwoModelRunClient.for_validation_failure(self.__api, model_id, data, validation_result)

        # Capture passed refs; use new correlation id
        correlation = Correlation(business_context = business_context) 

        # Do the run using the model id for efficiency
        run_id_response = self.__api.start_model_run_by_id(
            token, 
            model_id, 
            data, 
            security_groups, 
            correlation, 
            owner, 
            max_duration_days)

        # Do some logging as it's useful for the developer to see what's going on
        run_id = run_id_response.run_id
        model_id = str(model) if isinstance(model, FixedModelReference) else model
        info(f"Started run {run_id} for model {model_id}.")

        # Create a client specific to this run, for follow-on operations
        return MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, owner, model_id, data)


    # --- Added Value Method ---
    def start_model_run_with_data_and_context(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]], 
        contexts: List[ContextPath],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        mappers: List[ResponseMapper] = None,
        owner: str = None,
        max_duration_days: int = 1,
    ) -> MMEClassTwoModelRunClient:
        """Uses contexts to resolve inputs that have not been provided for a class two model, 
           and if this is successful, validates the provided data against the model then starts running that model.
           It provides an object help with monitoring the new run and obtaining both the inputs and the results. 

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            contexts: List[ContextPath] -- The list of context paths to use to try to resolve data for the model
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run -- after resolving inputs
                any security groups associated with resolved inputs will be added to the list provided
                May be omitted, which will default to no specific restrictions
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned
            owner: str -- The owner reference for the model run, which can be used to find active model runs (e.g. app_id+user_id)
                May be omitted, in which case a GUID is generated.
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer

        Returns:
            MMEClassTwoModelRunClient -- Helper class that allows the new run to be checked and results to be obtained when ready.

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """

        if security_groups is None:
            security_groups = []
        if mappers is None:
            mappers = []
        if owner is None:
            owner = str(uuid4())

        # resolve model requirements
        resolved_contexts = self.resolve_contexts(token, model, raw_inputs, contexts, mappers)
        if resolved_contexts.model_id is None or resolved_contexts.inputs is None or not resolved_contexts.requirements_fulfilled:
            return MMEClassTwoModelRunClient.for_unresolved_contexts(self.__api, resolved_contexts)

        model_id = resolved_contexts.model_id
        data = resolved_contexts.inputs

        # Validate inputs
        validation_result = self.__api.check_inputs_by_id(token, model_id, data)
        if not validation_result.all_passed:
            return MMEClassTwoModelRunClient.for_validation_failure(self.__api, model_id, data, validation_result)
        elif validation_result.warnings is not None and len(validation_result.warnings) > 0:
            debug("Inputs had validation warnings", ",".join(validation_result.warnings))

        ## add security from inputs
        security_groups = self.get_security_groups_associated_with_inputs(data, security_groups)
        
        # Capture passed refs; use new correlation ids
        correlation = Correlation(business_context = business_context) 

        # Do the run using the model id for efficiency
        run_id_response = self.__api.start_model_run_by_id(
            token, 
            model_id, 
            data, 
            security_groups, 
            correlation, 
            owner, 
            max_duration_days)

        # Do some logging as it's useful for the developer to see what's going on
        run_id = run_id_response.run_id
        model_id = str(model) if isinstance(model, FixedModelReference) else model
        info(f"Started run {run_id} for model {model_id}.")

        # Create a client specific to this run, for follow-on operations
        return MMEClassTwoModelRunClient.for_just_started(self.__api, token, run_id, owner, model_id, data)


    # --- Added Value Method ---
    async def run_with_data_async(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        owner: str = None, 
        max_duration_days: int = 1,
        check_interval_seconds: int = 5,
    ) -> RunProgress:
        """Validates the provided data against a class two model, then runs that model asynchronously, 
           returning an object which also contains the inputs. 

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run - typically taken from any resolved inputs
                May be omitted, which will default to no specific restrictions
            owner: str -- The owner reference for the model run, which can be used to find active model runs (e.g. app_id+user_id)
                May be omitted, in which case a GUID is generated.
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer
            check_interval_seconds: int -- How often to check the run progress, in seconds.

        Returns:
            RunProgress -- a helper class that gives information about what happened and aids result retrieval

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """
        run_client = self.start_model_run_with_data(
            token, 
            model, 
            raw_inputs, 
            business_context, 
            security_groups, 
            owner, 
            max_duration_days,
        )
        if run_client.run_progress.model_id is None or run_client.run_progress.inputs is None or \
            not run_client.run_progress.requirements_fulfilled \
            or (run_client.run_progress.validation_result is not None and not run_client.run_progress.validation_result.all_passed):
            return run_client.run_progress

        # Every second, check whether we have
        has_ended = False
        while not has_ended:
            await asyncio.sleep(check_interval_seconds)
            progress = run_client.update_progress()
            has_ended = progress.has_run

        return run_client.complete()


    # --- Added Value Method ---
    async def run_with_data_and_context_async(
        self,
        token: str, 
        model: Union[str, FixedModelReference],
        raw_inputs: List[Union[RawDatum, Datum]], 
        contexts: List[ContextPath],
        business_context: List[BusinessContext], 
        security_groups: List[str] = None,
        mappers: List[ResponseMapper] = None,
        owner: str = None, 
        max_duration_days: int = 1,
        check_interval_seconds: int = 5,
    ) -> RunProgress:
        """Uses contexts to resolve inputs that have not been provided for a class two model, 
           and if this is successful, validates the provided data against the model then runs that model asynchronously, 
           returning an object which also contains the inputs. Class two models are time-limited.

        Arguments:
            token: str -- The auth token to use for the API call
            model: Union[str, FixedModelReference] -- The model, either as an id or a reference:
                a model reference will be resolved automatically to an id
            raw_inputs: List[Union[RawDatum, Datum]] -- The list of input values to use. These can be full Datum
                - typically taken from resolved values; or RawDatum capturing user input
            contexts: List[ContextPath] -- The list of context paths to use to try to resolve data for the model
            business_context: List[BusinessContext] -- The definition of business context values to connect to the run
            security_groups: List[str] = None -- The security groups that apply to the run -- after resolving inputs
                any security groups associated with resolved inputs will be added to the list provided
                May be omitted, which will default to no specific restrictions
            mappers: List[ResponseMapper] = None -- The custom ResponseMappers to use to map resolved data to input responses
                - default behaviour is to take responses as they are returned
            owner: str -- The owner reference for the model run, which can be used to find active model runs (e.g. app_id+user_id)
                May be omitted, in which case a GUID is generated.
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer
            check_interval_seconds: int -- How often to check the run progress, in seconds.

        Returns:
            RunProgress -- a helper class that gives information about what happened and aids result retrieval

        Errors:
            ModelNotFound -- if model reference is not found
            InputNotValid -- if data, security_groups or correlation not specified correctly
            AuthNotValid -- if token is invalid
        """
        run_client = self.start_model_run_with_data_and_context(
            token, 
            model, 
            raw_inputs, 
            contexts,
            business_context, 
            security_groups, 
            mappers,
            owner, 
            max_duration_days,
        )
        if run_client.run_progress.model_id is None or run_client.run_progress.inputs is None or \
            not run_client.run_progress.requirements_fulfilled \
            or (run_client.run_progress.validation_result is not None and not run_client.run_progress.validation_result.all_passed):
            return run_client.run_progress

        # Every second, check whether we have
        has_ended = False
        while not has_ended:
            await asyncio.sleep(check_interval_seconds)
            progress = run_client.update_progress()
            has_ended = progress.has_run

        return run_client.complete()


    # --- Wrapper Method ---
    def find_model_runs_by_owner(
        self, 
        token: str, 
        owner: str,
        status: Union[ClassTwoRunStatus, List[ClassTwoRunStatus]] = [],
    ) -> ModelRuns:
        """Finds all of the class two model run ids linked to a particular owner.

        Arguments:
            token: str -- The auth token to use for the API call
            owner: str --  the owner reference provided when the runs were started
            status: ClassTwoRunStatus --  If set, filters the runs to just those with the given status,
                e.g. completed.

        Returns:
            ModelRuns -- List of all run ids for the owner, along with their statuses.

        Errors:
            AuthNotValid -- if token is invalid
        """
        model_runs = self.__api.find_model_runs_by_owner(token, owner)

        # Give the caller more flexibility on what to filter, if anything
        if isinstance(status, ClassTwoRunStatus):
            status = [status]
        
        if len(status) > 0:
            return ModelRuns([run for run in model_runs.runs if run.status in status])
        else:
            return model_runs


    # --- Wrapper Method ---
    def get_model_run_progress(
        self, 
        token: str, 
        run_id: str, 
        owner: str,
    ) ->  ModelRunProgress:
        """Checks the progress of an open model run.

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str -- The unique id of the model run to check progress for.
            owner: str --  The owner reference provided when the run was started.

        Returns:
           ModelRunProgress -- Details of the status of the run and any errors which have occurred.

        Errors:
            AuthNotValid -- if token is invalid
        """
        return self.__api.get_model_run_progress(token, run_id, owner)


    # --- Added Value Method ---
    def get_model_runs_progress_by_owner(
        self, 
        token: str, 
        owner: str,
        status: Union[ClassTwoRunStatus, List[ClassTwoRunStatus]] = [],
    ) ->  List[ModelRunProgress]:
        """Checks the detailed progress of all open model runs for the given owner.

        Arguments:
            token: str -- The auth token to use for the API call
            owner: str --  the owner reference provided when the runs were started.
            status: ClassTwoRunStatus --  If set, filters the runs to just those with the given status,
                e.g. completed.

        Returns:
           List[ModelRunProgress] -- Details of the status of the run and any errors which have occurred.

        Errors:
            AuthNotValid -- if token is invalid
        """
        model_runs = self.find_model_runs_by_owner(token, owner, status)
        progress = []
        for run in model_runs.runs:
            try:
                progress.append(self.get_model_run_progress(token, run.run_id, owner))
            except APIError as e:
                error(e)

        return progress


    # --- Wrapper Method ---
    def cancel_model_run(
        self, 
        token: str, 
        run_id: str, 
        owner: str,
    ) -> None:
        """Requests the cancellation of an open model run

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str -- The unique id of the model run to check progress for.
            owner: str --  The owner reference provided when the run was started.

        Errors:
            AuthNotValid -- if token is invalid
        """
        return self.__api.cancel_model_run(token, run_id, owner)


    # --- Wrapper Method ---
    def complete_model_run(
        self, 
        token:str, 
        run_id: str, 
        owner: str,
    ) -> RunOutput:
        """Completes the open async run of a model, closing the run and returning the results.

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str -- The unique id of the model run to check progress for.
            owner: str --  The owner reference provided when the run was started.

        Returns:
            RunOutput -- details of the result of the model run, including provenance details and results

        Errors:
            AuthNotValid -- if token is invalid
        """
        return self.__api.complete_model_run(token, run_id, owner)


    # --- Wrapper Method ---
    def register_use_of_models(
        self, 
        token: str, 
        system: str, 
        system_key: str, 
        user_key: str, 
        models: List[FixedModelReference],
    ) -> None:
        """Registers use of the specified models with MME

        Arguments:
            token: str -- The auth token to use for the API call
            system: str -- Identity of the registering system
            system_key: str -- Unique key for this use of models (uniqueness defined by registering system)
            user_key: str -- User friendly explanation of this use of models
            models: FixedModelReference -- List of the fixed reference of the model to register as being used

        Errors:
            AuthNotValid -- if token is invalid
        """
        return self.__api.register_use_of_models(token, system, system_key, user_key, models)


    # --- Wrapper Method ---
    def release_use_of_models(
        self, 
        token: str, 
        system: str, 
        system_key: str,
    ):
        """Registers use of the specified models with MME

        Arguments:
            token: str -- The auth token to use for the API call
            system: str -- Identity of the registering system
            system_key: str -- Unique key for this use of models (uniqueness defined by registering system)

        Errors:
            AuthNotValid -- if token is invalid
        """
        return self.__api.release_use_of_models(token, system, system_key)


    # --- Helper Method ---
    def __is_class_two_model(
        self, 
        token: str, 
        model: Union[str, FixedModelReference], 
    ) -> bool:
        return self.get_model_requirements(token, model).model_definition.model_classification == ModelClass.CLASS_TWO
