from datalab_sdk.api.exceptions import InputNotValid
from datalab_sdk.api.mme.basic import (
    InputDefinition,
    Response,
    RawValue,
    DataType,
    ContainerType,
    Unit,
    ListValue,
    NamedValue,
    SingularResponseContent,
    ArrayResponseContent,
    ContextPath
)
from datalab_sdk.api.mme.types.shared.datum import (
    DatumKey,
    Datum
)
from datalab_sdk.api.mme.response_mapper import ResponseMapper
from typing import Union, List, cast
from dataclasses import dataclass
from logging import debug

class NamedValueArrayMapper(ResponseMapper):
    """ Response Mapper that takes a response and maps it into a NamedValue Array.

        Any Single response with a non-tuple data type can be mapped to a 1-value array of Named Values.
        Additionally, any Array response with a non-tuple data type can mapped an Array of Named Values where multiple entries will have the same name.

        Any Single NamedValue response will be mapped to a 1-value array, and Array NamedValue responses will be passed through unchanged.
        All other values will pass through unchanged

        Constructor Arguments:
            applies_to: DatumKey -- The field this mapping should be applied to. If multiple fields need mapping, use multiple mapper instances
            key_context: ContextPath -- The piece of context defining the name of mapped values.
                                        The name for non-tuple types will be set to the first context_value_keys entry
    """

    def __init__(self,
        applies_to: DatumKey,
        key_context: ContextPath
    ):
        super().__init__([applies_to])
        self.__key_context = key_context

    def data_type(self, input_def: InputDefinition, response: Response) -> DataType:
        # if the type is mappable change to named value
        if self.__response_is_mappable(response):
            return DataType.NAMED_VALUE
        return response.data_type if response is not None else None

    def container_type(self, input_def: InputDefinition, response: Response) -> ContainerType:
        # if the type is mappable change to array
        if self.__response_is_mappable(response):
            return ContainerType.ARRAY
        return response.container_type if response is not None else None

    def singular_response_content(self, input_def: InputDefinition, response: Response) -> Union[SingularResponseContent, None]:
        # we will attempt conversion if type is mappable
        if self.__response_is_mappable(response):
            # so there is no singular value anymore
            return None
        return response.singular_response_content if response is not None else None

    def array_response_content(self, input_def: InputDefinition, response: Response) -> Union[ArrayResponseContent, None]:
        # attempt conversion if type is mappable
        if self.__response_is_mappable(response):
            raw_value = response.to_raw()
            if raw_value is not None:
                return self.__map_raw_value(response.data_type, response.container_type, raw_value)
        return response.array_response_content if response is not None else None

    def __response_is_mappable(self, response: Response) -> bool:
        # exclude the Tuple types we cannot represent in a Named Value
        return response is not None and not (
            response.data_type is DataType.TIME_POINT or
            response.data_type is DataType.COMPONENT_INGREDIENT or
            response.data_type is DataType.LIST_VALUE
        )

    def __map_raw_value(
        self, data_type: DataType, container_type: ContainerType, value: RawValue
    ) -> ArrayResponseContent:
        # define type-specific mapping
        key_name = self.__key_context.context_value_keys[0]
        mapping = {
            DataType.BOOLEAN: lambda x: NamedValue(name=key_name, boolean=x),
            DataType.STRING: lambda x: NamedValue(name=key_name, string=x),
            DataType.NUMBER: lambda x: NamedValue(name=key_name, number=x),
            DataType.DATE: lambda x: NamedValue.with_datetime(name=key_name, date=x), # raw dates are datetimes not strings
            DataType.NAMED_VALUE: lambda x: x,
        }

        if container_type is ContainerType.ARRAY and isinstance(value, list):
            mapped_value = list(map(mapping[data_type], value))
        else:
            mapped_value = [mapping[data_type](value)]

        return ArrayResponseContent(named_values=mapped_value)
