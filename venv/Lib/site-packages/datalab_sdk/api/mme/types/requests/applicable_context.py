from marshmallow_dataclass import dataclass
from typing import List, Dict, Tuple
from datalab_sdk.api.mme.types.requests.input_context import InputContext
from datalab_sdk.api.mme.types.requests.context_value import ContextValue
from datalab_sdk.api.common.schema import CamelCaseSchema
from datalab_sdk.api.mme.types.shared.datum_key import DatumKey
from datalab_sdk.api.mme.types.requests.context import Context
from datalab_sdk.api.mme.types.requests.context_path import ContextPath
from datalab_sdk.api.mme.types.shared.response import Response
from datalab_sdk.api.mme.types.shared.enums import DataType
import copy


@dataclass(base_schema=CamelCaseSchema)
class ApplicableContext:
    input_contexts: List[InputContext]
    fully_resolved: bool = False

    @property
    def valid_input_contexts(self) -> List[InputContext]:
        x = copy.deepcopy(self.input_contexts)
        contexts = self.__all_needed_contexts()
        for ix, input_context in enumerate(x):
            if input_context.needed_contexts is not None:
                ctx = x[ix].needed_contexts
                if ctx is not None:
                    for iy, needed_context in enumerate(input_context.needed_contexts):
                        ctx[iy].values = contexts[needed_context.context_key]
        return x

    @property
    def resolvable_applicable_context(self) -> "ApplicableContext":
        return ApplicableContext(
            fully_resolved=self.fully_resolved,
            input_contexts=[
                InputContext(
                    datum_key=x.datum_key,
                    selected_context_paths=x.selected_context_paths,
                )
                for x in self.input_contexts
            ],
        )

    @property
    def resolved_values(self) -> List[Tuple[DatumKey, Response]]:
        values = []
        for input_context in self.input_contexts:
            if input_context.resolved_response is not None and input_context.resolved_response.data_type is not DataType.NULL_DATA_TYPE:
                values += [(input_context.datum_key, input_context.resolved_response)]
        return values

    @property
    def needed_contexts(self) -> Dict[str, List[ContextValue]]:
        return self.__all_needed_contexts()

    def apply_selection(
        self, key: str, value_keys: List[str], system_set: bool = False
    ):
        for ix, input_context in enumerate(self.input_contexts):
            if input_context.needed_contexts is not None:
                for needed_context in input_context.needed_contexts:
                    if needed_context.context_key == key:
                        ctx = self.input_contexts[ix].selected_context_paths
                        if ctx is not None:
                            ctx.append(
                                ContextPath(
                                    context_key=key,
                                    context_value_keys=value_keys,
                                    system_set=system_set,
                                )
                            )

    def __all_needed_contexts(self) -> Dict[str, List[ContextValue]]:
        x: Dict[str, List[ContextValue]] = dict()
        for input_context in self.input_contexts:
            if input_context.needed_contexts is not None:
                for needed_context in input_context.needed_contexts:
                    if needed_context.context_key in x:
                        keys = list(
                            map(lambda x: x.context_value_key, needed_context.values)
                        )
                        x[needed_context.context_key] = list(
                            filter(
                                lambda x: x.context_value_key in keys,
                                x[needed_context.context_key],
                            )
                        )
                    else:
                        x[needed_context.context_key] = needed_context.values
        return x
