from marshmallow_dataclass import dataclass
from dataclasses import field
from datalab_sdk.api.mme.types.shared.unit import Unit
from typing import cast, Union, List
from datalab_sdk.api.mme.types.shared.singular_response_content import (
    SingularResponseContent,
    ListValue,
    TimePoint,
    ComponentIngredient,
    NamedValue,
)
from datalab_sdk.api.mme.types.shared.array_response_content import ArrayResponseContent
from datalab_sdk.api.common.schema import CamelCaseSchema
from datetime import datetime
from datalab_sdk.api.mme.types.shared.enums import DataType, ContainerType
from datalab_sdk.api.mme.types.shared.security import Security

RawValue = Union[
    str,
    float,
    int,
    datetime,
    bool,
    ListValue,
    TimePoint,
    ComponentIngredient,
    NamedValue,
    List[str],
    List[float],
    List[int],
    List[datetime],
    List[bool],
    List[ListValue],
    List[TimePoint],
    List[ComponentIngredient],
    List[NamedValue],
]


DATA_TYPE_MAPPING = {
    str: DataType.STRING,
    float: DataType.NUMBER,
    int: DataType.NUMBER,
    datetime: DataType.DATE,
    bool: DataType.BOOLEAN,
    ListValue: DataType.LIST_VALUE,
    TimePoint: DataType.TIME_POINT,
    ComponentIngredient: DataType.COMPONENT_INGREDIENT,
    NamedValue: DataType.NAMED_VALUE,
}

SELECTOR = {
    ContainerType.SINGLE: {
        DataType.STRING: lambda x: x.singular_response_content.string,
        DataType.NUMBER: lambda x: x.singular_response_content.number,
        DataType.DATE: lambda x: x.singular_response_content.date_as_datetime(),
        DataType.BOOLEAN: lambda x: x.singular_response_content.boolean,
        DataType.LIST_VALUE: lambda x: x.singular_response_content.list_value,
        DataType.TIME_POINT: lambda x: x.singular_response_content.time_point,
        DataType.COMPONENT_INGREDIENT: lambda x: x.singular_response_content.component_ingredient,
        DataType.NAMED_VALUE:lambda x: x.singular_response_content.named_value,
    },
    ContainerType.ARRAY: {
        DataType.STRING: lambda x: x.array_response_content.strings,
        DataType.NUMBER: lambda x: x.array_response_content.numbers,
        DataType.DATE: lambda x: x.array_response_content.dates_as_datetimes(),
        DataType.BOOLEAN: lambda x: x.array_response_content.booleans,
        DataType.LIST_VALUE: lambda x: x.array_response_content.list_values,
        DataType.TIME_POINT: lambda x: x.array_response_content.time_points,
        DataType.COMPONENT_INGREDIENT: lambda x: x.array_response_content.component_ingredients,
        DataType.NAMED_VALUE:lambda x: x.array_response_content.named_values,
    },
}

@dataclass(base_schema=CamelCaseSchema)
class Response:
    container_type: ContainerType = field(metadata=dict(by_value=True))
    data_type: DataType = field(metadata=dict(by_value=True))
    source: str = "script"
    timestamp: str = datetime.utcnow().isoformat()
    unit: Union[Unit, None] = None
    singular_response_content: Union[SingularResponseContent, None] = None
    array_response_content: Union[ArrayResponseContent, None] = None
    encrypted_response_content: Union[str, None] = None
    security: Union[Security, None] = None

    @classmethod
    def from_raw(
        cls,
        x: RawValue,
        unit: Union[Unit, None] = None,
        source: str = "script",
        timestamp: str = datetime.utcnow().isoformat(),
        security: Union[Security, None] = None,
    ):
        if isinstance(x, list):
            data_type = DATA_TYPE_MAPPING.get(type(x[0]), 0)

            return cls(
                unit=unit,
                source=source,
                timestamp=timestamp,
                container_type=ContainerType.ARRAY,
                data_type=cast(DataType, data_type),
                array_response_content=ArrayResponseContent.from_raw(x),
                security=security,
            )
        else:
            data_type = DATA_TYPE_MAPPING.get(type(x), 0)

            return cls(
                unit=unit,
                source=source,
                timestamp=timestamp,
                container_type=ContainerType.SINGLE,
                data_type=cast(DataType, data_type),
                singular_response_content=SingularResponseContent.from_raw(x),
                security=security,
            )

    @classmethod
    def from_raw_encrypted(
        cls,
        x: str,
        data_type: DataType,
        container_type: ContainerType,
        unit: Union[Unit, None] = None,
        source: str = "script",
        timestamp: str = datetime.utcnow().isoformat(),
        security: Union[Security, None] = None,
    ):
        if security is None:
          security = Security(secret=False, encrypted=True)

        return cls(
            unit=unit,
            source=source,
            timestamp=timestamp,
            container_type=container_type,
            data_type=data_type,
            encrypted_response_content=x,
            security=security,
        )

    def to_raw(self) -> Union[RawValue, None]:

        if self.security is None or not self.security.encrypted:
            if self.container_type in SELECTOR and self.data_type in SELECTOR[self.container_type]:
                return SELECTOR[self.container_type][self.data_type](self)
        return None

    # string implementation to aid comparisons
    def __str__(self):
        value = self.to_raw()
        if isinstance(value, list):
            return ",".join([str(x) for x in value])
        return str(value)
