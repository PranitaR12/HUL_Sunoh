from marshmallow_dataclass import dataclass
from datalab_sdk.api.common.schema import CamelCaseSchema
from datalab_sdk.api.mme.types.shared.datum_key import DatumKey
from datalab_sdk.api.mme.types.shared.response import Response, RawValue
from datalab_sdk.api.mme.types.shared.list_value import ListValue
from datalab_sdk.api.mme.types.shared.time_point import TimePoint
from datalab_sdk.api.mme.types.shared.named_value import NamedValue
from datalab_sdk.api.mme.types.shared.component_ingredient import ComponentIngredient
from typing import Union, List
from datetime import datetime
from datalab_sdk.api.mme.types.shared.enums import DataType
from datalab_sdk.api.mme.types.shared.unit import Unit
from datalab_sdk.api.mme.types.shared.security import Security
import iso8601

@dataclass(base_schema=CamelCaseSchema)
class Datum:
    datum_key: DatumKey
    response: Response

    @classmethod
    def from_raw(
        cls,
        datum_key: DatumKey,
        x: RawValue,
        unit: Union[Unit, None] = None,
        source: Union[None, str] = "script",
        timestamp: Union[None, str] = datetime.utcnow().isoformat(),
        security: Union[Security, None] = None,
    ):
        return cls(
            datum_key=datum_key,
            response=Response.from_raw(
                x,
                unit=unit,
                source="script" if source is None else source,
                timestamp= datetime.utcnow().isoformat()
                if timestamp is None
                else timestamp,
                security=security,
            ),
        )

    def contains_key(self, test_value: str) -> bool:
        value = test_value.upper() # keys have to be strings
        keys = self.__find_keys()
        if keys is None:
            return False
        return any([x == value for x in keys])

    def contains_value(self, test_value: str) -> bool:
        # values can be numbers so ensure we have a standardised form of the test string that will
        # best match number values
        value = self.__test_value_as_standardised_string(test_value)
        values = self.__find_inferred_values()
        if values is None:
            return False
        return any([x == value for x in values])

    def value_greater_than(self, test_value: str) -> bool:
        value = self.__test_value_as_number(test_value, self.response.data_type)
        if value is None:
            return False
        values = self.__find_inferred_numbers()
        if values is None:
            return False
        return any([x > value for x in values if x is not None])

    def value_less_than(self, test_value: str) -> bool:
        value = self.__test_value_as_number(test_value, self.response.data_type)
        if value is None:
            return False
        values = self.__find_inferred_numbers()
        if values is None:
            return False
        return any([x < value for x in values if x is not None])

    # define equality based on key not response
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.datum_key == other.datum_key
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.datum_key.to_hash_key())

    # helper to pull out all the "keys" from the response
    def __find_keys(self) -> Union[None, List[str]]:
        mapping = {
            ListValue: lambda x: x.symbolic.upper(),
            TimePoint: lambda x: x.date,
            ComponentIngredient: lambda x: x.name.upper(),
            NamedValue: lambda x: x.name.upper(),
        }
        return self.__map_response(mapping)

    # helper to determine if the set value is numeric
    def __has_numeric_value(self) -> bool:
        mapping = {
            bool: lambda x: False,
            datetime: lambda x: False,
            int: lambda x: True,
            float: lambda x: True,
            str: lambda x: False,
            ListValue: lambda x: False,
            NamedValue: lambda x: True
            if x.number is not None
            else False,
            TimePoint: lambda x: True
            if x.number is not None
            else False,
            ComponentIngredient: lambda x: False,
        }
        value = self.response.to_raw()
        if isinstance(value, list) and len(value) > 0:
            value = value[0]
        for t in mapping:
            if isinstance(value, t):
                return mapping[t](value)
        return False

    # helper to pull out all the "values" from the response
    def __find_inferred_values(self) -> Union[None, List[str]]:
        # ensure numeric values are consistently handled as floats
        mapping = {
            bool: lambda x: str(x).upper(),
            datetime: lambda x: x.isoformat().split('T')[0],
            int: lambda x: str(float(x)).upper(),
            float: lambda x: str(x).upper(),
            str: lambda x: x.upper(),
            ListValue: lambda x: x.display.upper(),
            NamedValue: lambda x: str(float(x.number)).upper()
            if x.number is not None
            else x.string.upper() if x.string is not None
            else x.date if x.date is not None
            else str(x.boolean).upper(),
            TimePoint: lambda x: str(float(x.number)).upper()
            if x.number is not None
            else x.string.upper(),
        }
        return self.__map_response(mapping)

    # helper to pull out all the numeric "values" from the response
    def __find_inferred_numbers(self) -> Union[None, List[float]]:
        # ensure values are consistently floats
        mapping = {
            bool: lambda x: float(int(x)),
            datetime: lambda x: x.timestamp() * 1e3,
            int: lambda x: float(x),
            float: lambda x: x,
            NamedValue: lambda x: float(x.number)
            if x.number is not None
            else float(int(x.boolean)) if x.boolean is not None
            else iso8601.parse_date(x.date).timestamp() * 1e3 if x.date is not None
            else None,
            TimePoint: lambda x: float(x.number)
            if x.number is not None
            else None,
        }
        return self.__map_to_floats(mapping)

    def __map_response(self, type_mapping) -> Union[None, List[str]]:
        value = self.response.to_raw()
        type_selector = self.response.to_raw()
        if isinstance(value, list) and len(value) > 0:
            type_selector = value[0]
        for t in type_mapping:
            if isinstance(type_selector, t):
                if isinstance(value, list):
                    return list(map(type_mapping[t], value))
                else:
                    return [type_mapping[t](value)]
        return None

    def __map_to_floats(self, type_mapping) -> Union[None, List[float]]:
        value = self.response.to_raw()
        type_selector = self.response.to_raw()
        if isinstance(value, list) and len(value) > 0:
            type_selector = value[0]
        for t in type_mapping:
            if isinstance(type_selector, t):
                if isinstance(value, list):
                    return list(map(type_mapping[t], value))
                else:
                    return [type_mapping[t](value)]
        return None

    def __test_value_as_number(self, test_value: str, data_type: DataType) -> Union[float, None]:
        try:
            if data_type == DataType.DATE:
                return iso8601.parse_date(test_value).timestamp() * 1e3
            return float(test_value)
        except:
            try:
                if data_type == DataType.NAMED_VALUE:
                    return iso8601.parse_date(test_value).timestamp() * 1e3
                return None
            except:
                return None

    def __test_value_as_standardised_string(self, test_value: str) -> str:
        if self.__has_numeric_value():
            try:
                # return float form if string is representable as a number
                return str(float(test_value)).upper()
            except ValueError as e:
                return test_value.upper()
        else:
            return test_value.upper()
