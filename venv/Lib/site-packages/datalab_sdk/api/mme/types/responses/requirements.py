from marshmallow_dataclass import dataclass
from dataclasses import field
from datalab_sdk.api.common.schema import CamelCaseSchema
from datalab_sdk.api.mme.types.shared.datum import Datum
from datalab_sdk.api.mme.types.shared.datum_key import DatumKey
from typing import Union, List
from enum import Enum


class RuleType(Enum):
    NULL_RULE_TYPE = "Unknown"
    REQUIRED_IF_EXACTLY_MATCH = "RequiredIfExactlyMatch"
    REQUIRED_IF_CONTAINS_KEY = "RequiredIfContainsKey"
    REQUIRED_IF_CONTAINS_VALUE = "RequiredIfContainsValue"
    REQUIRED_IF_VALUE_GREATER_THAN = "RequiredIfValueGreaterThan"
    REQUIRED_IF_VALUE_LESS_THAN = "RequiredIfValueLessThan"

# logic for evaluating each supported rule type
RULE_MAPPING = {
    RuleType.REQUIRED_IF_CONTAINS_KEY: lambda datum, test_value: datum.contains_key(test_value),
    RuleType.REQUIRED_IF_CONTAINS_VALUE: lambda datum, test_value: datum.contains_value(test_value),
    RuleType.REQUIRED_IF_EXACTLY_MATCH: lambda datum, test_value: str(datum.response).upper() == test_value.upper(),
    RuleType.REQUIRED_IF_VALUE_GREATER_THAN: lambda datum, test_value: datum.value_greater_than(test_value),
    RuleType.REQUIRED_IF_VALUE_LESS_THAN: lambda datum, test_value: datum.value_less_than(test_value)
}

@dataclass(base_schema=CamelCaseSchema)
class ConditionalRule:
    rule_type: RuleType = field(metadata=dict(by_value=True))
    additive: bool
    input_to_check: DatumKey
    test_values: List[str]

    def is_met(self, inputs: List[Datum]) -> bool:
        if self.rule_type in RULE_MAPPING:
            # any of the inputs match the check input
            return any(
                [
                    # any of the test values pass the rule
                    any([RULE_MAPPING[self.rule_type](x, y) for y in self.test_values])
                    for x in inputs
                    if x.datum_key == self.input_to_check
                ]
            )
        else:
            raise Exception("Unknown rule type")

@dataclass(base_schema=CamelCaseSchema)
class Requirements:
    always: bool
    conditional_rules: Union[List[ConditionalRule], None] = None

    @classmethod
    def none(cls):
        return cls(False, None)

    @classmethod
    def always_needed(cls):
        return cls(True, None)

    def is_required(self, inputs: List[Datum]) -> bool:
        if not self.always and self.conditional_rules is not None and len(self.conditional_rules) > 0:
            #evaluate all the rules
            additive_true = [r for r in self.conditional_rules if r.additive]
            additive_false = [r for r in self.conditional_rules if not r.additive]

            if len(additive_false) == 0:
                # just additive
                return all([r.is_met(inputs) for r in additive_true])
            elif len(additive_true) == 0:
                # just non-additive
                return any([r.is_met(inputs) for r in additive_false])
            else:
                # some of each
                return all([r.is_met(inputs) for r in additive_true]) or any([r.is_met(inputs) for r in additive_false])

        # no conditional rules
        return self.always
