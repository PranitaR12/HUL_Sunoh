from datalab_sdk.api.exceptions import InputNotValid
from datalab_sdk.api.mme.basic import (
    InputDefinition,
    Response,
    DataType,
    ContainerType,
    ListValue,
    NamedValue,
    SingularResponseContent,
    ArrayResponseContent
)
from datalab_sdk.api.mme.types.shared.datum import DatumKey
from datalab_sdk.api.mme.response_mapper import ResponseMapper
from typing import Union, List, cast
from logging import debug

class ToListValueMapper(ResponseMapper):
    """ Response Mapper that takes a response and matches it to the defined set of List Values for the input
        resulting in a ListValue Datum. Supports Singular or Array responses with NamedValue or String values

        Constructor Arguments:
            applies_to: List[DatumKey] = None -- The fields this mapping should be applied to. Defaults to all ListValue fields
            symbolic_match: bool = True -- True to match on symbolic value, False on Display value. Matches are case insensitive
            value_not_in_list: ListValue = None -- The value to return if the response value does not match any in the defined lis
                If no value is provided, then the response value will be mapped to a list value, but validation will fail if the
                list value is used with the model
            names_list: List[str] = None -- The expected set of names - useful in the NamedValue Array use case to ensure that
                resulting array matches the size and order expected; if not provided the order and size will be defined
                by the set of values in the source response
            missing_value: ListValue = None -- The list value to use when an item in the names_list has no value in the response.
                Not applicable if no names list is passed - but required if it is
            exact_name_match: bool = True -- If names_list set, True to match using string equals name; False to match using string contains name

        Errors:
            InputNotValid - if missing_value not provided when using names_list
    """

    def __init__(self,
        applies_to: List[DatumKey] = None,
        symbolic_match: bool = True,
        value_not_in_list: ListValue = None,
        names_list: List[str] = None,
        missing_value: ListValue = None,
        exact_name_match: bool = True,
    ):
        super().__init__(applies_to)
        self.__missing_value = missing_value
        self.__value_not_in_list = value_not_in_list
        self.__symbolic_match = symbolic_match
        self.__name_list = names_list
        self.__exact_name_match = exact_name_match

        if self.__name_list is not None and self.__missing_value is None:
            raise InputNotValid("missing_value must be set if name_list is provided")

    def applies_to(self, field: InputDefinition) -> bool:
        if super().applies_to(field):
            return field.data_definition.data_type == DataType.LIST_VALUE
        else:
            return False

    def data_type(self, input_def: InputDefinition, response: Response) -> DataType:
        return DataType.LIST_VALUE

    def container_type(self, input_def: InputDefinition, response: Response) -> ContainerType:
        return input_def.data_definition.container_definition.container_type

    def singular_response_content(self, input_def: InputDefinition, response: Response) -> Union[SingularResponseContent, None]:
        # attempt conversion if input def specifies a singular response
        if (
            response is not None
            and (response.security is None or not response.security.encrypted)
            and input_def.data_definition.container_definition.container_type == ContainerType.SINGLE
        ):
            value_set = input_def.display_definition.list_values
            search_string = self.__get_raw_as_search_string(response)
            if search_string is not None:
                value = self.__get_matching_list_value(search_string, value_set)
            else:
                return None
            return SingularResponseContent(list_value=value)
        else:
            return None

    def array_response_content(self, input_def: InputDefinition, response: Response) -> Union[ArrayResponseContent, None]:
        # attempt conversion if input def specifies an array response
        if (
            response is not None
            and (response.security is None or not response.security.encrypted)
            and input_def.data_definition.container_definition.container_type == ContainerType.ARRAY
        ):
            value_set = input_def.display_definition.list_values
            values: List[ListValue] = []

            if response.data_type == DataType.NAMED_VALUE:
                if self.__name_list is None:
                    for nv in self.__get_raw_as_list(response):
                        values.append(self.__get_matching_list_value(nv.string, value_set))
                else:
                    for name in self.__name_list:
                        test_value = name.lower()
                        found_value = self.__missing_value
                        for nv in self.__get_raw_as_list(response):
                            returned_name = nv.name.lower()
                            if (self.__exact_name_match and test_value == returned_name) or (not self.__exact_name_match and test_value in returned_name):
                                found_value = self.__get_matching_list_value(nv.string, value_set)
                                break
                        values.append(cast(ListValue,found_value))

            elif response.data_type == DataType.STRING:
                for string in self.__get_raw_as_list(response):
                    values.append(self.__get_matching_list_value(string, value_set))
            else:
                return None

            return ArrayResponseContent(list_values=values)
        else:
            return None

    def __get_matching_list_value(self, search_value: str, lvs: List[ListValue]) -> ListValue:
        for lv in lvs:
            if self.__get_list_value_to_match(lv) == search_value.lower():
                return lv
        debug(f"No match found for returned value {search_value}")
        if self.__value_not_in_list is not None:
            return self.__value_not_in_list
        else:
            return ListValue(search_value, search_value)

    def __get_list_value_to_match(self, lv: ListValue) -> str:
        if self.__symbolic_match:
            return lv.symbolic.lower()
        else:
            if lv.display is not None:
                return lv.display.lower()
            else:
                # use symbolic if no display
                return lv.symbolic.lower()

    def __get_raw_as_list(self, response: Response) -> List:
        if response.container_type == ContainerType.ARRAY:
            return cast(List, response.to_raw())
        else:
            # turn into list
            return [response.to_raw()]

    def __get_raw_as_search_string(self, response: Response) -> Union[str, None]:
        search_string : Union[str, None] = None

        # get the raw value, or first if a list
        raw_value = response.to_raw()
        if isinstance(raw_value, list):
            raw_value = raw_value[0]

        if response.data_type == DataType.NAMED_VALUE:
            nv = cast(NamedValue, raw_value)
            if nv.string is not None:
                search_string = nv.string
        elif response.data_type == DataType.STRING:
            search_string = cast(str, raw_value)

        return search_string
