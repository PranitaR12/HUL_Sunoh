from logging import info, debug
from typing import Type, TypeVar, Union, List, Callable, Mapping, Optional

from marshmallow_dataclass import class_schema

from datalab_sdk.api.exceptions import * # want to make easy import for clients of SDK
from datalab_sdk.api.raw import RawClient, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)
# import the likely types so clients don't need to know where to find them
from typing import Any, Dict
from logging import error
from datalab_sdk.api.mme.exceptions import *
from datalab_sdk.api.mme.types.requests.model_by_id import ModelById
from datalab_sdk.api.mme.types.requests.model_by_reference import ModelByReference
from datalab_sdk.api.mme.types.requests.model_inputs_by_id import ModelInputsById
from datalab_sdk.api.mme.types.requests.model_inputs_by_reference import ModelInputsByReference
from datalab_sdk.api.mme.types.requests.resolve_input_contexts import ApplicableContext, ResolveInputContexts
from datalab_sdk.api.mme.types.requests.check_input_by_id import CheckInputById
from datalab_sdk.api.mme.types.requests.model_reference import FixedModelReference, SoftModelReference, ModelReference
from datalab_sdk.api.mme.types.requests.input_context import InputContext, ContextPath, Context
from datalab_sdk.api.mme.types.requests.run_model_by_id import RunModelById, Datum, Correlation, BusinessContext, Security
from datalab_sdk.api.mme.types.requests.run_model_by_reference import RunModelByReference
from datalab_sdk.api.mme.types.requests.resolve_model_request import ResolveModelRequest
from datalab_sdk.api.mme.types.requests.model_usage import RegisterUsage, ReleaseUsage
from datalab_sdk.api.mme.types.requests.start_model_run_by_id import StartModelRunById
from datalab_sdk.api.mme.types.requests.start_model_run_by_ref import StartModelRunByReference
from datalab_sdk.api.mme.types.requests.owner import Owner
from datalab_sdk.api.mme.types.requests.run_state_request import RunStateRequest
from datalab_sdk.api.mme.types.responses.model_runs import ModelRuns
from datalab_sdk.api.mme.types.responses.resolve_model_response import ResolveModelResults, ModelResolveResult
from datalab_sdk.api.mme.types.responses.container_definition import ContainerDefinition
from datalab_sdk.api.mme.types.responses.data_definition import DataDefinition
from datalab_sdk.api.mme.types.responses.display_definition import DisplayDefinition
from datalab_sdk.api.mme.types.responses.input_validation_result import InputsValidationResult
from datalab_sdk.api.mme.types.responses.input_group_definition import InputGroupDefinition
from datalab_sdk.api.mme.types.responses.input_definition import InputDefinition
from datalab_sdk.api.mme.types.responses.model_definition import ModelDefinition
from datalab_sdk.api.mme.types.responses.model_outputs import ModelOutputs
from datalab_sdk.api.mme.types.responses.model_requirements import ModelRequirements
from datalab_sdk.api.mme.types.responses.requirements import Requirements
from datalab_sdk.api.mme.types.responses.run_output import RunOutput
from datalab_sdk.api.mme.types.responses.success_response import SuccessResponse
from datalab_sdk.api.mme.types.responses.model_run_progress import ModelRunProgress
from datalab_sdk.api.mme.types.responses.run_id import RunId
from datalab_sdk.api.common.schema import CamelCaseSchema
from datalab_sdk.api.mme.types.shared.datum import DatumKey, Response
from datalab_sdk.api.mme.types.shared.response import * # want to make easy import for clients of SDK
from datalab_sdk.api.mme.types.shared.enums import *
from datalab_sdk.api.mme.types.shared.unit import Unit, UnitFamily
from datalab_sdk.logger import logger

INPUT_CLASS = TypeVar("INPUT_CLASS")
OUTPUT_CLASS = TypeVar("OUTPUT_CLASS")

SYSTEM_AUTH_HEADER = "X-ASSOCIATED-SYSTEM-ID"
SYSTEM_USER_HEADER = "X-ASSOCIATED-USER-ID"


class MMEBasicClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)


    def check_models_can_be_resolved(
        self, 
        token: str, 
        models: List[ModelReference], 
        min_state: ModelState = ModelState.PUBLISHED,
        compatible_time_point:str = None
    ) -> ResolveModelResults:
        """Tries to resolve the model references into specific models to run

        Arguments:
            token: str -- The auth token to use for the API call
            models: List[ModelReference] -- List of the fixed references to model that should be resolved
            min_state: ModelState = ModelState.PUBLISHED -- optional minimum state that the model must be in to be
                resolved. This defaults to PUBLISHED. The Resolve results will give available state if a model
                fails to resolve due to not meeting the min state.
            compatible_time_point: Timeformat ISO 8601 string (optional parameter)

        Returns:
            ResolveResults - per-model results of the attempt to resolve.

        Errors:
            AuthNotValid - if token is invalid
        """
        return self.__request_post(
            path="checkModelsCanBeResolved",
            token=token,
            data=ResolveModelRequest(models, min_state, compatible_time_point),
            input_class=ResolveModelRequest,
            output_class=ResolveModelResults,
        )


    def get_model_requirements_by_id(
        self, 
        token: str, 
        model_id: str, 
        lookup_contexts: bool = True,
    ) -> ModelRequirements:
        """Find the requirements for running the specified model

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the model to address
            lookup_contexts: bool = True -- optional flag to control if MME should perform the costly operation to
                find contexts that apply to the model inputs. Usually this is needed, but not always

        Returns:
            ModelRequirements - full definition of requirements to run the model

        Errors:
            ModelNotFound - if model id is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="getModelRequirementsById",
            token=token,
            data=ModelInputsById(model_id, lookup_contexts),
            input_class=ModelInputsById,
            output_class=ModelRequirements,
            not_found=lambda x: ModelNotFound(model_id, x),
        )


    def get_model_requirements_by_reference(
        self, 
        token: str, 
        model_reference: FixedModelReference,
        lookup_contexts: bool = True,
    ) -> ModelRequirements:
        """Find the requirements for running the specified model

        Arguments:
            token: str -- The auth token to use for the API call
            model_reference: FixedModelReference -- The fixed reference of the model to address
            lookup_contexts: bool = True -- optional flag to control if MME should perform the costly operation to
                find contexts that apply to the model inputs. Usually this is needed, but not always

        Returns:
            ModelRequirements - full definition of requirements to run the model, includes the model details with model id

        Errors:
            ModelNotFound - if model reference is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="getModelRequirementsByReference",
            token=token,
            data=ModelInputsByReference(model_reference, lookup_contexts),
            input_class=ModelInputsByReference,
            output_class=ModelRequirements,
            not_found=lambda x: ModelNotFound(str(model_reference), x),
        )


    def get_model_outputs_by_id(
        self, 
        token: str, 
        model_id: str,
    ) -> ModelOutputs:
        """Get the definition of the outputs the model will return

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the model to address

        Returns:
            ModelOutputs - full definition of outputs the model will returns

        Errors:
            ModelNotFound - if model id is not found
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="getModelOutputsById",
            token=token,
            data=ModelById(model_id),
            input_class=ModelById,
            output_class=ModelOutputs,
            not_found=lambda x: ModelNotFound(model_id, x),
        )


    def resolve_input_contexts(
        self, 
        token: str, 
        applicable_context: ApplicableContext,
    ) -> ApplicableContext:
        """Try to resolve applicable contexts into Responses that can be used with a model

        Arguments:
            token: str -- The auth token to use for the API call
            applicable_context: ApplicableContext -- The current definition of contexts that apply
                and the context paths that are currently applied

        Returns:
            ApplicableContext - updated definition of contexts that apply, with any values that have been resolved

        Errors:
            InputNotValid - if applicable_context not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="resolveInputContexts",
            token=token,
            data=ResolveInputContexts(applicable_context),
            input_class=ResolveInputContexts,
            output_class=ApplicableContext,
        )


    def check_inputs_by_id(
        self, token: str, model_id: str, data: List[Datum],
    ) -> InputsValidationResult:
        """Check if the provided inputs are ready to be sent to the model

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the model to address
            data: List[Datum] -- The list of Datum defining the input values to check

        Returns:
            InputsValidationResult - details of the validation results for each provided input

        Errors:
            ModelNotFound - if model id is not found
            InputNotValid - if data not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="checkModelInputsReady",
            token=token,
            data=CheckInputById(model_id, data),
            input_class=CheckInputById,
            output_class=InputsValidationResult,
            not_found=lambda x: ModelNotFound(model_id, x),
        )


    def run_model_by_id(
        self, 
        token: str, 
        model_id: str, 
        data: List[Datum], 
        security_groups: List[str],
        correlation: Correlation,
    ) -> RunOutput:
        """Run the model with the provided inputs. These should have been checked first

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the model to address
            data: List[Datum] -- The list of Datum defining the input values to use
            security_groups: List[str] -- The security groups that apply to the run - typically taken from any resolved inputs
            correlation: Correlation -- The definition of run context to connect to wider business work flows

        Returns:
            RunOutput - details of the result of the model run, including provenance details and results

        Errors:
            ModelNotFound - if model id is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="runModelById",
            token=token,
            data=RunModelById(model_id, data, security_groups, correlation),
            input_class=RunModelById,
            output_class=RunOutput,
            not_found=lambda x: ModelNotFound(model_id, x),
        )


    def run_model_by_reference(
        self, 
        token: str, 
        model_reference: FixedModelReference, 
        data: List[Datum], 
        security_groups: List[str],
        correlation: Correlation,
    ) -> RunOutput:
        """Run the model with the provided inputs. These should have been checked first

        Arguments:
            token: str -- The auth token to use for the API call
            model_reference: FixedModelReference -- The fixed reference of the model to address
            data: List[Datum] -- The list of Datum defining the input values to use
            security_groups: List[str] -- The security groups that apply to the run - typically taken from any resolved inputs
            correlation: Correlation -- The definition of run context to connect to wider business work flows

        Returns:
            RunOutput - details of the result of the model run, including provenance details and results

        Errors:
            ModelNotFound - if model id is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
            AuthNotValid - if token is invalid
        """

        return self.__request_post(
            path="runModelByReference",
            token=token,
            data=RunModelByReference(model_reference, data, security_groups, correlation),
            input_class=RunModelByReference,
            output_class=RunOutput,
            not_found=lambda x: ModelNotFound(str(model_reference), x),
        )


    def register_use_of_models(
        self, 
        token: str, 
        system: str, 
        system_key: str, 
        user_key: str, 
        models: List[FixedModelReference],
    ):
        """Registers use of the specified models with MME

        Arguments:
            token: str -- The auth token to use for the API call
            system: str -- Identity of the registering system
            system_key: str -- Unique key for this use of models (uniqueness defined by registering system)
            user_key: str -- User friendly explanation of this use of models
            models: FixedModelReference -- List of the fixed reference of the model to register as being used

        Errors:
            AuthNotValid - if token is invalid
        """

        str_models = ", ".join(list(map(lambda x: str(x), models)))

        self.__request_post(
            path="registerUseOfModels",
            token=token,
            data=RegisterUsage(system, system_key, user_key, models),
            input_class=RegisterUsage,
            output_class=SuccessResponse,
            not_found=lambda x: ModelNotFound(f"one of {str_models}", x),
        )


    def release_use_of_models(
        self, 
        token: str, 
        system: str, 
        system_key: str,
    ):
        """Registers use of the specified models with MME

        Arguments:
            token: str -- The auth token to use for the API call
            system: str -- Identity of the registering system
            system_key: str -- Unique key for this use of models (uniqueness defined by registering system)

        Errors:
            AuthNotValid - if token is invalid
        """

        self.__request_post(
            path="releaseUseOfModels",
            token=token,
            data=ReleaseUsage(system, system_key),
            input_class=ReleaseUsage,
            output_class=SuccessResponse,
        )


    def start_model_run_by_id(
        self, 
        token: str, 
        model_id: str, 
        data: List[Datum], 
        security_groups: List[str],
        correlation: Correlation, 
        owner: str, 
        max_duration_days: int,
    ) -> RunId:
        """Starts running the model with the provided inputs. These should have been checked first.

        Arguments:
            token: str -- The auth token to use for the API call
            model_id: str -- The id of the model to address
            data: List[Datum] -- The list of Datum defining the input values to use
            security_groups: List[str] -- The security groups that apply to the run - typically taken from any resolved inputs
            correlation: Correlation -- The definition of run context to connect to wider business work flows
            owner: str -- The owner reference for the model run, which can be used to find active model runs
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer

        Errors:
            AuthNotValid - if token is invalid
            ModelNotFound - if model id is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
        """
        return self.__request_post(
            path="startModelRunById",
            token=token,
            data=StartModelRunById(model_id, data, security_groups, correlation, owner, max_duration_days),
            input_class=StartModelRunById,
            output_class=RunId,
            not_found=lambda x: ModelNotFound(model_id, x),
        )


    def start_model_run_by_reference(
        self, 
        token: str, 
        model_reference: FixedModelReference, 
        data: List[Datum], 
        security_groups: List[str],
        correlation: Correlation, 
        owner: str, 
        max_duration_days: int,
    ) -> RunId:
        """Starts running the model with the provided inputs. These should have been checked first.

        Arguments:
            token: str -- The auth token to use for the API call
            model_reference: FixedModelReference -- The fixed reference of the model to address
            data: List[Datum] -- The list of Datum defining the input values to use
            security_groups: List[str] -- The security groups that apply to the run - typically taken from any resolved inputs
            correlation: Correlation -- The definition of run context to connect to wider business work flows
            owner: str -- The owner reference for the model run, which can be used to find active model runs
            max_duration_days: int -- the number of days that the model should be allowed to run for. Must be an integer

        Errors:
            AuthNotValid - if token is invalid
            ModelNotFound - if model id is not found
            InputNotValid - if data, security_groups or correlation not specified correctly
        """
        return self.__request_post(
            path="startModelRunByReference",
            token=token,
            data=StartModelRunByReference(model_reference, data, security_groups, correlation, owner, max_duration_days),
            input_class=StartModelRunByReference,
            output_class=RunId,
            not_found=lambda x: ModelNotFound(str(model_reference), x),
        )


    def find_model_runs_by_owner(
        self, 
        token: str, 
        owner: str,
    ) -> ModelRuns:
        """Finds all of the class two model run ids linked to a particular owner.

        Arguments:
            token: str -- The auth token to use for the API call
            owner: str --  The owner reference provided when the runs were started

        Returns:
            ModelRuns -- List of all run ids for the owner, along with their statuses.

        Errors:
            AuthNotValid - if token is invalid
        """
        return self.__request_get(
            path=f"findModelRunsByOwner/{owner}",
            token=token,
            output_class=ModelRuns
        )


    def get_model_run_progress(
        self, 
        token: str, 
        run_id: str, 
        owner: str,
    ) ->  ModelRunProgress:
        """Checks the progress of an open model run.

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str - the unique id of the model run to check progress for.
            owner: str --  the owner reference provided when the run was started

        Errors:
            AuthNotValid - if token is invalid
        """
        return self.__request_get(
          path=f"modelRunProgress/{run_id}?owner={owner}",
          token=token,
          output_class=ModelRunProgress
        )


    def cancel_model_run(
        self, 
        token: str, 
        run_id: str, 
        owner: str,
    ) -> None:
        """Requests the cancellation of an open model run

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str - the unique id of the model run to check progress for.
            owner: str --  the owner reference provided when the run was started

        Errors:
            AuthNotValid - if token is invalid
        """
        self.__request_post(
            path="cancelModelRun",
            token=token,
            data=RunStateRequest(run_id, owner),
            input_class=RunStateRequest,
            output_class=None
        )


    def complete_model_run(
        self, 
        token:str, 
        run_id: str, 
        owner: str,
    ) -> RunOutput:
        """Completes the open async run of a model, closing the run and returning the results.

        Arguments:
            token: str -- The auth token to use for the API call
            run_id: str - the unique id of the model run to check progress for.
            owner: str --  the owner reference provided when the run was started

        Errors:
            AuthNotValid - if token is invalid
        """
        return self.__request_post(
            path="completeModelRun",
            token=token,
            data=RunStateRequest(run_id, owner),
            input_class=RunStateRequest,
            output_class=RunOutput
        )


    def __request_get(
        self, 
        path: str, 
        token: str, 
        output_class: Type[OUTPUT_CLASS],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None
    ) -> OUTPUT_CLASS:
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)
        # make call
        url = EnvironmentConfig.get_mme_api_url(self._environment, path)
        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.get(url, token ))
        except ResourceNotFound as err:
            logger.debug(err)
            if not_found is not None:
                # Convert MME specific errors
                raise not_found(err.correlation_id)
            else:
                raise err
        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)


    def __request_post(
        self, 
        path: str, 
        token: str, 
        data: INPUT_CLASS,
        input_class: Type[INPUT_CLASS], 
        output_class: Optional[Type[OUTPUT_CLASS]],
        not_found: Union[Callable[[str], ResourceNotFound], None] = None,
    ) -> OUTPUT_CLASS:
        input_schema = class_schema(input_class, base_schema=CamelCaseSchema)

        # prepare input body - may be invalid
        try:
            body = input_schema().dump(data)
            info(body)
        except Exception as err:
            logger.debug(err)
            debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        # make call
        url = EnvironmentConfig.get_mme_api_url(self._environment, path)

        # Special case where we don't expect a response
        if output_class is None:
            try:
                response = self.post(url, token, body, parse_response=False)
            except ResourceNotFound as err:
                logger.debug(err)
                if not_found is not None:
                    # Convert MME specific errors
                    raise not_found(err.correlation_id)
                else:
                    raise err
            return cast(OUTPUT_CLASS, None)

        # Otherwise, handle output schema
        output_schema = class_schema(output_class, base_schema=CamelCaseSchema)
        try:
            # can safely cast to JSONResponseType since parse_json defaults to True
            response = cast(JSONResponseType, self.post(url, token, body))
        except ResourceNotFound as err:
            if not_found is not None:
                # Convert MME specific errors
                raise not_found(err.correlation_id)
            else:
                raise err

        # prepare outputs
        info(response)
        try:
            return output_schema().load(response)
        except:
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

