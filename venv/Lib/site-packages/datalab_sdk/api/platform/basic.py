from logging import info, debug, error
from typing import Any, Dict, Type, TypeVar, Union, List, Callable, Mapping, cast

import requests
import json
import shutil

from datalab_sdk.api.exceptions import * # want to make easy import for clients of SDK
from datalab_sdk.api.raw import RawClient, ResponseType, JSONResponseType
from datalab_sdk.config.environment import (
    Environment,
    EnvironmentConfig
)
from datalab_sdk.api.platform.types.metadata import *
from datalab_sdk.logger import logger

from datalab_sdk.api.platform.schema import PermissiveCamelCaseSchema
from datalab_sdk.api.common.utils import convert_id_function

UpsertCallType=Callable[[str, str, Mapping[str,Any],bool], ResponseType]

class PlatformBasicClient(RawClient):
    def __init__(self, environment: Environment = Environment.PROD):
        super().__init__(environment)

################################################################################
# UPLOADS
################################################################################

    def upload_file(
      self, token, metadata : UploadRequestMetadata, filename: str, data: bytes
    ) -> UploadResponse:
        """Upload a file with the provided metadata
        Arguments:
            token: str -- The auth token to use for the API call
            metadata: UploadRequestMetadata -- The metadata details to associate with the file
            filename: str -- The filename the file should have if it is downloaded again
            data: -- the contents of the file as a bytes object

        Returns:
            UploadResponse - details of the new repo

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, "")
        return self.__upsert_logic(self.multipart_post, url, token, metadata, filename, data)

    def update_repo(
      self, token: str, repo_id: str,  metadata : UploadRequestMetadata, filename: str, data: bytes
    ) -> UploadResponse:
        """Upload a repo with the provided file and metadata

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The repo to update
            metadata: UploadRequestMetadata -- The metadata details to associate with the file
            filename: str -- The filename the file should have if it is downloaded again
            data: -- the contents of the file as a bytes object

        Returns:
            UploadResponse - details of the new repo

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, repo_id)
        return self.__upsert_logic(self.multipart_put, url, token, metadata, filename, data)

    def update_metadata(
      self, token: str, repo_id: str,  metadata : UploadRequestMetadata
    ) -> UpdateMetadataResponse:
        """Update a repo with the provided metadata

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The repo to update
            metadata: UploadRequestMetadata -- The metadata details to associate with the file

        Returns:
            UpdateMetadataResponse - id of the repo

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"{repo_id}/metadata")
        metadata_body = self.__create_metadata_body(metadata)
        update_response_metadata_schema = class_schema(UpdateMetadataResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, metadata_body, update_response_metadata_schema)
        return cast(UpdateMetadataResponse, response)

    def update_lower_access_metadata(
      self, token: str, repo_id: str, metadata: UploadRequestMetadata
    ) -> UpdateMetadataResponse:
        """Update lower access metadata for a repository.

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The ID of the repository to update
            metadata: UploadRequestMetadata -- The metadata details to associate with the file

        Returns:
            UpdateMetadataResponse - An object containing the ID of the repository

        Errors:
            InputNotValid - If metadata is not specified correctly
            AuthNotValid - If the token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"{repo_id}/metadata/lower")
        metadata_body = self.__create_metadata_body(metadata)
        update_response_metadata_schema = class_schema(UpdateMetadataResponse,          base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, metadata_body, update_response_metadata_schema)
        return cast(UpdateMetadataResponse, response)


    def __upsert_logic(self, method: UpsertCallType, url :str, token: str, metadata: UploadRequestMetadata, filename: str, data: bytes
    ) -> UploadResponse:
        """Shared logic for repo create and update functions
        """
        metadata_body = self.__create_metadata_body(metadata)
        fields = {
          "file" : (filename, data),
          "metadata": json.dumps(metadata_body)
        }
        upload_response_metadata_schema = class_schema(UploadResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(method, url, token, fields, upload_response_metadata_schema)
        return cast(UploadResponse, response)

    def __create_metadata_body(self, metadata: UploadRequestMetadata) -> UploadRequestMetadata:
        """Shared logic for for creating the metadata object
        """
        upload_request_metadata_schema = class_schema(UploadRequestMetadata, base_schema=CamelCaseSchema)

        try:
            metadata_body = upload_request_metadata_schema().dump(metadata)
            info(metadata_body)
        except Exception as err:
            debug(err)
            logger.debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        return metadata_body

    def __create_is_locked_body(self, is_locked: IsLockedRequest) -> UploadRequestMetadata:
        """Shared logic for for creating the metadata object
        """
        is_locked_request_schema = class_schema(IsLockedRequest, base_schema=CamelCaseSchema)

        try:
            is_locked_body = is_locked_request_schema().dump(is_locked)
            info(is_locked_body)
        except Exception as err:
            debug(err)
            logger.debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        return is_locked_body

    def __create_is_obsolete_body(self, is_obsolete: IsObsoleteRequest) -> UploadRequestMetadata:
        """Shared logic for creating the metadata object for setting IsObsolete field."""
        is_obsolete_request_schema = class_schema(IsObsoleteRequest, base_schema=CamelCaseSchema)

        try:
            is_obsolete_body = is_obsolete_request_schema().dump(is_obsolete)
            info(is_obsolete_body)
        except Exception as err:
            debug(err)
            logger.debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        return is_obsolete_body

    def __upload_with_method(self, method: UpsertCallType, url :str, token: str, body, return_schema
    ) -> Union[UpdateMetadataResponse, UploadResponse]:
        """Shared logic for sending request and error handling
        """
        response = cast(Mapping[str, Any], method(url, token, body, True))
        modified_response = self._convert_to_camel_ids(response)

        try:
          return return_schema().load(modified_response)
        except Exception as e:
            print(e)
            logger.debug(e)
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    def __create_termination_date_body(self, termination_date: SetTerminationDateObject) -> SetTerminationDateObject:
        """Creates the request body for setting the termination date of a repository."""

        termination_date_object_schema = class_schema(SetTerminationDateObject, base_schema=CamelCaseSchema)

        try:
            # Serialize the data class to a dictionary
            termination_date_body = termination_date_object_schema().dump(termination_date)
            info(termination_date_body)
            return termination_date_body
        except ValidationError as err:
            debug(err)
            logger.debug(err)
            raise InputNotValid("The provided termination date data did not match expected content for this API call")

################################################################################
# METADATA
################################################################################

    def get_metadata(self, token: str, repo_id: str
    ) -> RepoMetadata:
        """Get a summary of the current metadata for a repo

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The RepoId of the repo

        Returns:
            RepoMetadata - a summary of the repo metadata

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/repo/{repo_id}/metadata")
        response = cast(Mapping, self.get(url, token))
        modified_response = self._convert_to_camel_ids(response)

        info(modified_response)
        try:
          output_schema = class_schema(RepoMetadata, base_schema=CamelCaseSchema)
          return output_schema().load(modified_response)
        except Exception as e:
            print(e)
            logger.debug(e)
            correlation_id = None
            if isinstance(modified_response, Mapping) and "correlationId" in modified_response:
                  # capture correlation if present
                  correlation_id = modified_response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)


    def update_is_locked(self, token: str, repo_id: str, is_locked: bool
    ) -> UpdateIsLockedResponse:
        """Updates whether the given repository is locked.

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The repository Id
            is_locked: bool -- Whether the repo is locked.

        Returns:
            UpdateIsLockedResponse - id of the repo

        Errors:
            InputNotValid - if is locked is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"{repo_id}/islocked")
        metadata_body = self.__create_is_locked_body(IsLockedRequest(is_locked))
        update_response_metadata_schema = class_schema(UpdateIsLockedResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, metadata_body, update_response_metadata_schema)
        return cast(UpdateIsLockedResponse, response)

    def set_is_obsolete(self, token: str, repo_id: str, is_obsolete: bool) -> UpdateIsObsoleteResponse:
        """Sets the IsObsolete field of a repository.

        Arguments:
            token: str -- The authentication token for the API call.
            repo_id: str -- The ID of the repository.
            is_obsolete: bool -- The value to set for the IsObsolete field.

        Returns:
            UpdateIsObsoleteResponse -- The response containing information about the operation.

        Errors:
            InputNotValid -- If the provided body data does not match the expected content.
            AuthNotValid -- If the authentication token is invalid.
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"{repo_id}/isobsolete")
        metadata_body = self.__create_is_obsolete_body(IsObsoleteRequest(is_obsolete))
        set_response_metadata_schema = class_schema(UpdateIsObsoleteResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, metadata_body, set_response_metadata_schema)
        return cast(UpdateIsObsoleteResponse, response)

    def set_repository_termination_date(self, token: str, repo_id: str, termination_date: int) -> UpdateMetadataResponse:
        """Sets the TerminationDate field of a repository."""
        url = EnvironmentConfig.get_public_api_url(self._environment, f"{repo_id}/terminationDate")

        termination_date_object = SetTerminationDateObject(termination_date=termination_date)

        termination_date_body = self.__create_termination_date_body(termination_date_object)

        response = self.__upload_with_method(
            method=requests.put,
            url=url,
            token=token,
            body=termination_date_body,
            return_schema=class_schema(UpdateMetadataResponse))

        return cast(UpdateMetadataResponse, response)

################################################################################
# FIXED REPO VERSION DOWNLOADS
################################################################################

    def download_fixed_version_of_binary_file(self, token: str, data_id: str
     ) -> BinaryFileSchema:
        """Download a fixed version of a file (specificed by its DataId)
           as a binary blob

        Arguments:
            token: str -- The auth token to use for the API call
            data_id: str -- The DataId of the file to download

        Returns:
            BinaryFileSchema - The filename and its content

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/id/{data_id}")
        # can safely cast to Response object since parse_json is false
        r = cast(requests.Response, self.get(url, token, parse_response=False))
        info(r)
        return BinaryFileSchema(r.headers["filename"], r.content)

    def download_fixed_version_of_text_file(self, token: str, data_id: str
    ) -> TextFileSchema:
        """Download a fixed version of a file (specificed by its DataId)i
           as text

        Arguments:
            token: str -- The auth token to use for the API call
            data_id: str -- The DataId of the file to download

        Returns:
            BinaryFileSchema - The filename and its decoded content

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/id/{data_id}")
        r = cast(requests.Response, self.get(url, token, parse_response=False))
        info(r)
        return TextFileSchema(r.headers["filename"], r.text)

    def get_streamable_response_for_fixed_file_version(self, token: str, data_id: str
    ) -> requests.Response:
        """Get response object for streaming a fixed version of a file

        Arguments:
            token: str -- The auth token to use for the API call
            data_id: str -- The DataId of the file to download

        Returns:
            requests.response - a requests response object suitable for streaming

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/id/{data_id}")
        r = cast(requests.Response, self.get(url, token, parse_response=False, stream = True))
        info(r)
        return r

    def stream_fixed_version_to_file(self, token: str, data_id: str, local_path: str ) -> None:
        """Stream a fixed version of a file direct to a local file

        Arguments:
            token: str -- The auth token to use for the API call
            data_id: str -- The DataId of the file to download
            local_path: str -- The local path to stream to

        Returns:
            requests.response - a requests response object suitable for streaming

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        with self.get_streamable_response_for_fixed_file_version(token, data_id) as r:
            info(r)
            if local_path is not None:
                dest_path = local_path
            else:
                dest_path = r.headers["filename"]
            with open(dest_path, 'wb') as f:
                shutil.copyfileobj(r.raw, f)

################################################################################
# LATEST REPO VERSION DOWNLOADS
################################################################################

    def download_latest_version_of_binary_file(self, token: str, repo_id: str
     ) -> BinaryFileSchema:
        """Download the latest version of a repo (specificed by its RepoId)
           as a binary blob

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The RepoId of the file to download

        Returns:
            BinaryFileSchema - The filename and its content

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/latest/{repo_id}")
        # can safely cast to Response object since parse_json is false
        r = cast(requests.Response, self.get(url, token, parse_response=False))
        info(r)
        return BinaryFileSchema(r.headers["filename"], r.content)

    def download_latest_version_of_text_file(self, token: str, repo_id: str
    ) -> TextFileSchema:
        """Download the latest version of a file (specificed by its RepoId)
           as text

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The RepoId of the file to download

        Returns:
            BinaryFileSchema - The filename and its decoded content

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/latest/{repo_id}")
        r = cast(requests.Response, self.get(url, token, parse_response=False))
        info(r)
        return TextFileSchema(r.headers["filename"], r.text)

    def get_streamable_response_for_latest_file_version(self, token: str, repo_id: str
    ) -> requests.Response:
        """Get response object for streaming the latest version of a file

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The RepoId of the file to download

        Returns:
            requests.response - a requests response object suitable for streaming

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/latest/{repo_id}")
        r = cast(requests.Response, self.get(url, token, parse_response=False, stream = True))
        info(r)
        return r

    def stream_latest_version_to_file(self, token: str, repo_id: str, local_path: str = None
    ) -> None:
        """Stream the latest version of a file direct to a local file

        Arguments:
            token: str -- The auth token to use for the API call
            repo_id: str -- The RepoId of the file to download
            local_path: str -- The local path to stream to

        Returns:
            requests.response - a requests response object suitable for streaming

        Errors:
            InputNotValid - if metadata is not specified correctly
            AuthNotValid - if token is invalid
        """
        with self.get_streamable_response_for_latest_file_version(token, repo_id) as r:
            info(r)
            if local_path is not None:
                dest_path = local_path
            else:
                dest_path = r.headers["filename"]
            with open(dest_path, 'wb') as f:
                shutil.copyfileobj(r.raw, f)


################################################################################
# PLATFORM SEARCH
################################################################################

    def file_search(
        self,
        token: str,
        search_term: str,
        tags: List[str] = None,
        key_value_facets: List[KeyValueFacet] = None,
        page: int = None
    ) -> FileSearchResponse:
        """Search the immutable store for files with the given filters

        Arguments:
            token: str -- The auth token to use for the API call
            search_term: str -- The term to search for
            tags: List[str] -- List of the tags to search for
            key_value_facets: List[KeyValueFacet] -- List of the key value facets
            page: int -- The page of results to return


        Returns:
            FileSearchResponse - A dict containing the list of results and whether the search has a next page

        Errors:
            InputNotValid - if inputs are not specified correctly
            AuthNotValid - if token is invalid
        """
        return self.__search_logic(token, search_term, tags, key_value_facets, page, mme_search_only=False)

    def mme_model_search(
        self,
        token: str,
        search_term: str,
        tags: List[str] = None,
        key_value_facets: List[KeyValueFacet] = None,
        page: int = None
    ) -> FileSearchResponse:
        """Search the immutable store for class one MME models with the given filters

        Arguments:
            token: str -- The auth token to use for the API call
            search_term: str -- The term to search for
            tags: List[str] -- List of the tags to search for
            key_value_facets: List[KeyValueFacet] -- List of the key value facets
            page: int -- The page of results to return


        Returns:
            FileSearchResponse - A dict containing the list of results and whether the search has a next page

        Errors:
            InputNotValid - if inputs are not specified correctly
            AuthNotValid - if token is invalid
        """
        return self.__search_logic(token, search_term, tags, key_value_facets, page, mme_search_only=True)

    def udiscover_search(
        self,
        token: str,
        search_term: str,
        tags: List[str] = None,
        key_value_facets: List[KeyValueFacet] = None,
        page: int = None
    ) -> FileSearchResponse:
        """Search the udiscover database for entries matching the given filters."""
        return self.__search_logic(token, search_term, tags, key_value_facets, page, udiscover_search_only=True)

    def tools_search(
        self,
        token: str,
        search_term: str,
        tags: List[str] = None,
        key_value_facets: List[KeyValueFacet] = None,
        page: int = None
    ) -> FileSearchResponse:
        """Search the tools database for entries matching the given filters."""
        return self.__search_logic(token, search_term, tags, key_value_facets, page, tools_search_only=True)

    def __search_logic(
        self,
        token: str,
        search_term: str,
        tags: List[str] = None,
        key_value_facets: List[KeyValueFacet] = None,
        page: int = None,
        mme_search_only: bool = False,
        udiscover_search_only: bool = False,
        tools_search_only: bool = False
    ):
        """Shared logic for search requests which differ only by endpoint."""
        if mme_search_only:
            url_path = "/search/mme"
        elif udiscover_search_only:
            url_path = "/search/udiscover"
        elif tools_search_only:
            url_path = "/search/tools"
        else:
            url_path = "/search"

        url = EnvironmentConfig.get_public_api_url(self._environment, url_path)
        search_request = SearchRequestBody(
            search_term=search_term,
            tags=tags,
            key_value_facets=key_value_facets,
            page=page
        )
        search_request_body_schema = class_schema(SearchRequestBody, base_schema=CamelCaseSchema)
        file_search_response_schema = class_schema(FileSearchResponse, base_schema=PermissiveCamelCaseSchema)

        try:
            body = search_request_body_schema().dump(search_request)
            info(body)
        except Exception as err:
            debug(err)
            logger.debug(err)
            raise InputNotValid("The provided body data did not match expected content for this API call")

        response = cast(Mapping[str, Any], self.post(url, token, body, True))

        try:
            return file_search_response_schema().load(response)
        except Exception as e:
            print(e)
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                # capture correlation if present
                correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

    @staticmethod
    def _convert_to_camel_ids(input: Mapping) -> Mapping:
        return dict( (convert_id_function(k),v) for k,v in input.items())

################################################################################
# USERDATA
################################################################################

    def get_user_data(self, token: str
    ) -> UserData:
        """Get user profile details:
            oid email AD Groups username

        Arguments:
            token: str -- The auth token to use for the API call

        Returns:
            UserData - a summary of the User data

        Errors:
            AuthNotValid - if token is invalid
        """
        try:
            url = EnvironmentConfig.get_public_api_url(self._environment, f"/user/me")
            response = cast(Mapping, self.get(url, token))
            output_schema = class_schema(UserData, base_schema=LowerCamelCaseSchema)
            return output_schema().load(response)
        except Exception as e:
            print(e)
            logger.debug(e)
            correlation_id = None
            if isinstance(response, Mapping) and "correlationId" in response:
                  # capture correlation if present
                  correlation_id = response["correlationId"]
            raise APIChanged("Could not parse response into output schema", correlation_id, 400)

################################################################################
# DATASET
################################################################################

    def get_dataset(self, token: str, dataset_id: str
    ) -> JSONResponseType:
        """Gets a dataset by its ID

        Arguments:
            token: str -- The auth token to use for the API call
            dataset_id: str -- The dataset Id

        Returns:
            Dataset - a JSON object

        Errors:
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/dataset/{dataset_id}")
        dataset = cast(Mapping, self.get(url, token))
        info(dataset)
        return dataset

    def set_dataset_locked(self, token: str, dataset_id: str, is_locked: bool) -> UpdateIsLockedResponse:
        """Sets the IsLocked field of a dataset.

        Arguments:
            token: str -- The auth token to use for the API call
            dataset_id: str -- The dataset ID
            is_locked: bool -- Whether the dataset is locked

        Returns:
            UpdateIsLockedResponse - ID of the dataset

        Errors:
            InputNotValid - if is_locked is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/dataset/{dataset_id}/islocked")
        is_locked_body = self.__create_is_locked_body(IsLockedRequest(is_locked))
        update_response_schema = class_schema(UpdateIsLockedResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, is_locked_body, update_response_schema)
        return cast(UpdateIsLockedResponse, response)

    def set_dataset_obsolete(self, token: str, dataset_id: str, is_obsolete: bool) -> UpdateIsObsoleteResponse:
        """Sets the IsObsolete field of a dataset.

        Arguments:
            token: str -- The auth token to use for the API call
            dataset_id: str -- The dataset ID
            is_obsolete: bool -- Whether the dataset is obsolete

        Returns:
            UpdateIsObsoleteResponse - ID of the dataset

        Errors:
            InputNotValid - if is_obsolete is not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, f"/dataset/{dataset_id}/isobsolete")
        is_obsolete_body = self.__create_is_obsolete_body(IsObsoleteRequest(is_obsolete))
        update_response_schema = class_schema(UpdateIsObsoleteResponse, base_schema=CamelCaseSchema)

        response = self.__upload_with_method(self.put, url, token, is_obsolete_body, update_response_schema)
        return cast(UpdateIsObsoleteResponse, response)

    def get_group_names(self, token: str) -> List[str]:
        """Gets a list of the available groups.

        Arguments:
            token: str -- The auth token to use for the API call

        Returns:
            List[str] - A list of group names

        Errors:
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, "/groupnames")
        response = self.get(url, token)
        groups_response_schema = class_schema(GroupsResponse,base_schema=PermissiveCamelCaseSchema)

        group_response = groups_response_schema().load(response)
        return group_response

    def search_datasets(self, token: str, search_request_body: SearchRequestBody) ->    SearchResponse:
        """Performs a search for datasets with the given criteria.

        Arguments:
            token: str -- The auth token to use for the API call
            search_request_body: SearchRequestBody -- The search criteria

        Returns:
            SearchResponse - The search results

        Errors:
            InputNotValid - if search criteria are not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, "/dataset/search")
        search_request_body_schema = class_schema(SearchRequestBody,    base_schema=CamelCaseSchema)
        search_response_schema = class_schema(SearchResponse, base_schema=PermissiveCamelCaseSchema)

        body = search_request_body_schema().dump(search_request_body)
        response = self.post(url, token, body)
        return search_response_schema().load(response)

    def create_dataset(self, token: str, dataset_body: UpsertDatasetRequestBody) -> IDResponse:
        """Create a dataset with the provided details.

        Arguments:
            token: str -- The auth token to use for the API call
            dataset_body: UpsertDatasetRequestBody -- The details of the dataset to create

        Returns:
            IDResponse - The response with the ID of the created dataset

        Errors:
            InputNotValid - if dataset details are not specified correctly
            AuthNotValid - if token is invalid
        """
        url = EnvironmentConfig.get_public_api_url(self._environment, "/dataset/")
        dataset_body_schema = class_schema(UpsertDatasetRequestBody, base_schema=CamelCaseSchema)
        id_response_schema = class_schema(IDResponse, base_schema=CamelCaseSchema)

        body = dataset_body_schema().dump(dataset_body)
        response = self.post(url, token, body)
        return id_response_schema().load(response)

################################################################################
# Download Msks Data
################################################################################

    def get_msks_data_file(self,token:str,filepath:str)->BinaryFileSchema:
        """Gets MSKS data file by filepath

        Arguments:
            token: str -- The auth token to use for the API call
            filepath: str -- The filepath of the blob

        Returns:
            file - a JSON object

        Errors:
            AuthNotValid - if token is invalid
        """
        try:
            url = EnvironmentConfig.get_public_api_url(self._environment, f"/msksData/?filepath={filepath}")

            msksdataResponse = cast(requests.Response, self.get(url, token,False,True))
            info(msksdataResponse)
            return BinaryFileSchema(msksdataResponse.headers["filename"], msksdataResponse.content)
        except Exception as err:
            correlation_id = None
            if "_APIError__correlation" in err.__dict__:
                # capture correlation if present
                correlation_id = err.__dict__['_APIError__correlation']
            raise InternalError("Could not parse response into output schema", correlation_id, err.__dict__['_APIError__status_code'])
