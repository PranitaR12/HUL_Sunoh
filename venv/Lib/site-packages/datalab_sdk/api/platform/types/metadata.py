
from marshmallow import ValidationError
from marshmallow_dataclass import dataclass, class_schema, Optional
from marshmallow import Schema, fields
from enum import Enum
from typing import Dict, Union, List
from datalab_sdk.api.common.schema import *
from datalab_sdk.api.platform.schema import *

class KeyValueType(Enum):
    STRING = "STRING"
    NUMBER = "NUMBER"
    BOOLEAN = "BOOLEAN"
    DATE  = "DATE"


@dataclass(base_schema=CamelCaseSchema)
class KeyValueField:
    key: str
    value: Union[str, int, float, bool]
    type: KeyValueType
    category_path: List[str]


@dataclass(base_schema=CamelCaseSchema)
class UploadRequestMetadata:
    name: str
    description: str
    tags: List[str]
    key_value_fields: List[KeyValueField]
    version_id: str
    read_only_access_groups: Optional[List[str]]=None
    enable_mme_access: bool=False

@dataclass(base_schema=CamelCaseSchema)
class IsLockedRequest:
    is_locked: bool

@dataclass(base_schema=CamelCaseSchema)
class IsObsoleteRequest:
    is_obsolete: bool

@dataclass(base_schema=CamelCaseSchema)
class UploadResponse:
    name: str
    description: str
    data_id: Optional[str]
    repo_id: Optional[str]
    tags: List[str]
    key_value_fields: List[KeyValueField]
    access_groups: List[str]
    enable_mme_access: bool=False

@dataclass(base_schema=CamelCaseSchema)
class BinaryFileSchema:
    name: str
    contents: bytes
@dataclass(base_schema=CamelCaseSchema)
class TextFileSchema:
    name: str
    contents: str

@dataclass(base_schema=CamelCaseSchema)
class UpdateMetadataResponse:
    id: str

@dataclass(base_schema=CamelCaseSchema)
class UpdateIsLockedResponse:
    id: str

@dataclass(base_schema=CamelCaseSchema)
class UpdateIsObsoleteResponse:
    id: str

@dataclass(base_schema=KeyValueFacetFromToSchema)
class KeyValueFacetFromTo:
    facet_to: int
    facet_from: int

class KeyValueSearchType(Enum):
    string = "string"
    number = "number"
    boolean = "boolean"
    date = "date"

@dataclass(base_schema=CamelCaseSchema)
class KeyValueFacet:
    key: str
    type: KeyValueSearchType
    values: Union[KeyValueFacetFromTo, List[str], List[bool]]

@dataclass(base_schema=CamelCaseSchema)
class SearchRequestBody:
    search_term: str
    tags: Optional[List[str]]
    key_value_facets: Optional[List[KeyValueFacet]]
    page: Optional[int]

@dataclass(base_schema=CamelCaseSchema)
class FileSearchItem:
    repo_id: str
    data_id: str
    name: str
    description: str
    tags: List[str]
    key_value_fields: List[KeyValueField]
    access_groups: List[str]
    is_obsolete: bool
    is_locked: bool
    is_terminated: bool
    owner: str=""
    created_by: str=""
    last_updated: int=0
    last_updated_by: str=""

@dataclass(base_schema=PermissiveCamelCaseSchema)
class FileSearchResponse:
    results: List[FileSearchItem]
    next: bool

@dataclass(base_schema=CamelCaseSchema)
class GroupsResponse():
    groups = fields.List(fields.String(), required=True)

@dataclass(base_schema=CamelCaseSchema)
class RepoMetadata:
    repo_id: str
    name: str
    description: str
    tags: List[str]
    key_value_fields: List[KeyValueField]
    access_groups: List[str]
    read_only_access_groups: Optional[List[str]]=None
    enable_mme_access: bool=False
    owner: str=""
    created_by: str=""
    last_updated: int=0
    last_updated_by: str=""
    last_updated_by_id: str=""
    latest_data_id: str=""

@dataclass(base_schema=LowerCamelCaseSchema)
class UserData:
    oid: str
    email: str
    ad_groups: Dict[str, str]
    user_name: str

@dataclass(base_schema=CamelCaseSchema)
class SetTerminationDateObject:
    termination_date: int

@dataclass(base_schema=CamelCaseSchema)  # Use CamelCase for consistency
class FileObject:
    description: str
    type: Any
    required: bool


@dataclass(base_schema=CamelCaseSchema)
class SearchItem:
    repo_id: str
    data_id: str
    name: str
    description: str
    tags: List[str]
    key_value_fields: List[KeyValueField]
    access_groups: List[str]
    is_obsolete: bool
    is_locked: bool
    is_terminated: bool

@dataclass(base_schema=CamelCaseSchema)
class DatasetItem:
    dataset_id: str
    children: 'DatasetChildren'
    is_obsolete: bool
    is_locked: bool

@dataclass(base_schema=CamelCaseSchema)
class DatasetChildren:
    repos: List[SearchItem]
    datasets: List['DatasetItem']

# Recursive structure for NestedObject
NestedObject = DatasetItem

@dataclass(base_schema=CamelCaseSchema)
class SearchResponse:
    results: Union[List[SearchItem], List[DatasetItem]]
    next: bool

@dataclass(base_schema=CamelCaseSchema)
class KeyValueFieldProtoObject:
    key: str
    value: Any
    type: str
    category_path: List[str]

@dataclass(base_schema=CamelCaseSchema)
class DatasetRequestProto:
    dataset_id: str
    name: str
    description: str
    tags: List[str]
    access_groups: List[str]
    read_only_access_groups: List[str]
    key_value_fields: List[KeyValueFieldProtoObject]
    owner: str

@dataclass(base_schema=CamelCaseSchema)
class IdsChanged:
    added: List[Any]
    removed: List[Any]

@dataclass(base_schema=CamelCaseSchema)
class UpsertDatasetRequestBody:
    dataset: DatasetRequestProto
    repo_ids: IdsChanged
    dataset_ids: IdsChanged

@dataclass(base_schema=CamelCaseSchema)
class IDResponse:
    id: str
